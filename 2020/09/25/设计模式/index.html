<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <title>设计模式 - IceBerg</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/images/growd.png" type="image/png" />
  <meta name="description" content="设计模式软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。   一共有">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://example.com/2020/09/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="IceBerg">
<meta property="og:description" content="设计模式软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。   一共有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%B1%BB.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E6%8E%A5%E5%8F%A3%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%B1%BB%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E4%B8%80%E8%88%AC%E5%85%B3%E8%81%94.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E6%B3%9B%E5%8D%8E%E5%85%B3%E7%B3%BB.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/UML%E4%B8%AD%E7%9A%84%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/UML%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E5%AE%9E%E4%BE%8B%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/Windows%E4%B8%BB%E9%A2%98%E8%AE%BE%E8%AE%A1.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%87%A0%E7%BB%B4%E9%B8%9F%E4%B8%8D%E6%98%AF%E9%B8%9F.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%87%A0%E7%BB%B4%E9%B8%9F%E6%98%AF%E5%8A%A8%E7%89%A9.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E9%A1%BE%E5%AE%A2%E8%B4%AD%E7%89%A9%E7%A8%8B%E5%BA%8F.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%B1%BB%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E6%98%8E%E6%98%9F%E4%B8%8E%E7%BB%8F%E7%BA%AA%E4%BA%BA%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%94%A8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B1%BD%E8%BD%A6%E5%88%86%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%94%A8%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B1%BD%E8%BD%A6%E5%88%86%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/美国总统生成器的结构图.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%8C%AA%E5%85%AB%E6%88%92%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E6%9C%89%E9%99%90%E7%9A%84%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AD%99%E6%82%9F%E7%A9%BA%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A5%96%E7%8A%B6%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%B8%A6%E5%8E%9F%E5%9E%8B%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%9B%BE%E5%BD%A2%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%94%B5%E5%99%A8%E5%B7%A5%E5%8E%82%E7%9A%84%E4%BA%A7%E5%93%81%E7%AD%89%E7%BA%A7%E4%B8%8E%E4%BA%A7%E5%93%81%E6%97%8F.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%86%9C%E5%9C%BA%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%86%9C%E5%9C%BA%E5%85%BB%E6%AE%96%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AE%A2%E5%8E%85%E8%A3%85%E4%BF%AE%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E9%9F%B6%E5%85%B3%E2%80%9C%E5%A4%A9%E8%A1%97e%E8%A7%92%E2%80%9D%E5%85%AC%E5%8F%B8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8F%91%E5%8A%A8%E6%9C%BA%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8F%8C%E5%90%91%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A5%B3%E5%A3%AB%E7%9A%AE%E5%8C%85%E9%80%89%E8%B4%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%81%94%E7%94%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E2%80%9C%E8%8E%AB%E8%8E%89%E5%8D%A1%C2%B7%E5%AE%89%E6%96%AF%E5%85%B0%E2%80%9D%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%85%B7%E4%BD%93%E6%9E%84%E4%BB%B6%E7%9A%84%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%85%B7%E4%BD%93%E8%A3%85%E9%A5%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8A%9E%E7%90%86%E6%88%BF%E4%BA%A7%E8%AF%81%E8%BF%87%E6%88%B7%E7%9A%84%E7%9B%B8%E5%85%B3%E9%83%A8%E9%97%A8.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A4%96%E8%A7%82%EF%BC%88Facade%EF%BC%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A9%BA%E6%BA%90%E7%89%B9%E4%BA%A7%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%BC%95%E5%85%A5%E6%8A%BD%E8%B1%A1%E5%A4%96%E8%A7%82%E7%B1%BB%E7%9A%84%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8D%95%E7%BA%AF%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A4%8D%E5%90%88%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E9%80%8F%E6%98%8E%E5%BC%8F%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AE%89%E5%85%A8%E5%BC%8F%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E9%9B%86%E5%90%88c0%E7%9A%84%E6%A0%91%E7%8A%B6%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E9%9F%B6%E5%85%B3%E2%80%9C%E5%A4%A9%E8%A1%97e%E8%A7%92%E2%80%9D%E5%BA%97%E8%B4%AD%E7%89%A9%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A4%8D%E6%9D%82%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%87%BA%E5%9B%BD%E7%95%99%E5%AD%A6%E6%89%8B%E7%BB%AD%E8%AE%BE%E8%AE%A1%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%90%AB%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A4%A7%E9%97%B8%E8%9F%B9%E5%81%9A%E8%8F%9C%E7%AD%96%E7%95%A5%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A4%A7%E9%97%B8%E8%9F%B9%E5%81%9A%E8%8F%9C%E7%BB%93%E6%9E%9C.jpg">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A9%BA%E6%BA%90%E6%97%85%E6%B8%B8%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%AD%96%E7%95%A5%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AE%A2%E6%88%B7%E5%9C%A8%E9%A4%90%E9%A6%86%E5%90%83%E6%97%A9%E9%A4%90%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%BB%84%E5%90%88%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E8%B4%A3%E4%BB%BB%E9%93%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E8%AF%B7%E5%81%87%E6%9D%A1%E5%AE%A1%E6%89%B9%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E4%BA%BA%E6%B0%91%E5%B8%81%E6%B1%87%E7%8E%87%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AD%A6%E6%A0%A1%E9%93%83%E5%A3%B0%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AD%A6%E6%A0%A1%E9%93%83%E5%A3%B0%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8E%9F%E6%B2%B9%E6%9C%9F%E8%B4%A7%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E9%9F%B6%E5%85%B3%E6%88%BF%E5%9C%B0%E4%BA%A7%E4%BA%A4%E6%B5%81%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E9%9F%B6%E5%85%B3%E6%88%BF%E5%9C%B0%E4%BA%A7%E4%BA%A4%E6%B5%81%E5%B9%B3%E5%8F%B0%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%AE%80%E5%8C%96%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A9%BA%E6%BA%90%E6%97%85%E6%B8%B8%E9%A3%8E%E6%99%AF%E5%9B%BE%E6%B5%8F%E8%A7%88%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%BB%84%E5%90%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E8%AE%BF%E9%97%AE%E8%80%85%EF%BC%88Visitor%EF%BC%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E8%89%BA%E6%9C%AF%E5%85%AC%E5%8F%B8%E4%B8%8E%E9%80%A0%E5%B8%81%E5%85%AC%E5%8F%B8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8C%85%E5%90%AB%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%9B%B8%E4%BA%B2%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E5%B8%A6%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E2%80%9C%E6%88%91%E6%98%AF%E5%A4%A7%E5%AD%A6%E7%94%9F%E2%80%9D%E7%9A%84%E8%AF%AD%E6%B3%95%E6%A0%91.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="og:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E2%80%9C%E9%9F%B6%E7%B2%B5%E9%80%9A%E2%80%9D%E5%85%AC%E4%BA%A4%E8%BD%A6%E8%AF%BB%E5%8D%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif">
<meta property="article:published_time" content="2020-09-25T01:50:58.000Z">
<meta property="article:modified_time" content="2020-09-25T02:33:23.596Z">
<meta property="article:author" content="iceberg">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/bigpaozz/img_md/raw/master/%E7%B1%BB.gif">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/nexmoe/nexmoe.github.io@latest/lib/mdui_043tiny/css/mdui.css,gh/nexmoe/nexmoe.github.io@latest/lib/iconfont/iconfont.css?v=233" crossorigin>
  
  <link rel="stylesheet" href="/css/style.css?v=1601001529619">
<meta name="generator" content="Hexo 5.2.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://gitee.com/bigpaozz/img_md/raw/master/hexo/wallpaper/风景建筑自然/1592929109562.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="iceberg" class="mdui-btn mdui-btn-icon"><img src="https://gitee.com/bigpaozz/img_md/raw/master/hexo/growd.png" alt="iceberg"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="iceberg">
            <img src="https://gitee.com/bigpaozz/img_md/raw/master/hexo/growd.png" alt="iceberg" alt="iceberg">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>3</div>
        <div><span>标签</span>3</div>
        <div><span>分类</span>2</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://jq.qq.com/?_wv=1027&k=5CfKHun" target="_blank" mdui-tooltip="{content: 'QQ群'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a><a class="mdui-ripple" href="https://space.bilibili.com/" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Java/">Java</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/设计模式/">设计模式</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/hello/" style="font-size: 10px;">hello</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a>
    </div>
    
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>


<style>
.nexmoe-widget .archive-list-count{
	position : absolute;
	right: 15px;
	top:9px;
	color: #DDD;
}
</style>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2020 iceberg
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
  
      <div class="nexmoe-post-cover" style="padding-bottom: 66.66666666666666%;"> 
          <img data-src="https://gitee.com/bigpaozz/img_md/raw/master/hexo/wallpaper/风景建筑自然/1592929109562.jpg" data-sizes="auto" alt="设计模式" class="lazyload">
          <h1>设计模式</h1>
      </div>
  
  
  <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2020年09月25日</a>
    <a><i class="nexmoefont icon-areachart"></i>55.1k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 252 分钟</a>
</div>

  <div class="nexmoe-post-right">
    
  </div>

  <article>
    <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。 </p>
<blockquote>
<p>一共有23中设计模式, 这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 </p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">模式 &amp; 描述</th>
<th align="left">包括</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>创建型模式</strong> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>
<td align="left"><strong>工厂模式</strong>（Factory Pattern）               <strong>抽象工厂模式</strong>（Abstract Factory Pattern）           <strong>单例模式</strong>（Singleton Pattern）           <strong>建造者模式</strong>（Builder Pattern）                                          <strong>原型模式</strong>（Prototype Pattern）</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td align="left"><strong>适配器模式</strong>（Adapter Pattern）                     <strong>桥接模式</strong>（Bridge Pattern）                                                             过滤器模式（Filter、Criteria Pattern）      组合模式（Composite Pattern）                                         装饰器模式（Decorator Pattern）                 外观模式（Facade Pattern）                                                        享元模式（Flyweight Pattern）                      <strong>代理模式</strong>（Proxy Pattern）</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>行为型模式</strong> 这些设计模式特别关注对象之间的通信。</td>
<td align="left">责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>J2EE 模式</strong> 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td>
<td align="left">MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）                    组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern）</td>
</tr>
</tbody></table>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p> 统一建模语言（Unified Modeling Language，UML）是用来设计软件蓝图的可视化建模语言， 它具有简单、统一、图形化、能表达软件设计中的动态与静态信息等特点。</p>
<h3 id="类、接口和类图"><a href="#类、接口和类图" class="headerlink" title="类、接口和类图"></a>类、接口和类图</h3><h4 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h4><p>类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含<strong>类名</strong>、<strong>属性</strong>和<strong>操作</strong>且带有分隔线的矩形来表示。 </p>
<blockquote>
<p> “可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）4 种，在类图中分别用符号+、-、#、~表示。 </p>
</blockquote>
<p><img data-sizes="auto" data-src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%B1%BB.gif" alt="类" class="lazyload"></p>
<h4 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h4><p>接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。 </p>
<p><img data-sizes="auto" data-src="https://gitee.com/bigpaozz/img_md/raw/master/%E6%8E%A5%E5%8F%A3%E5%9B%BE.gif" alt="接口图" class="lazyload"></p>
<h4 id="3-类图"><a href="#3-类图" class="headerlink" title="3.类图"></a>3.类图</h4><p>类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。</p>
<p><img data-sizes="auto" data-src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%B1%BB%E5%9B%BE.gif" alt="类图" class="lazyload"></p>
<h3 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h3><h4 id="1-依赖关系"><a href="#1-依赖关系" class="headerlink" title="1. 依赖关系"></a>1. 依赖关系</h4><p>依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。 </p>
<blockquote>
<p>依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。 </p>
</blockquote>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.gif"></p>
<h4 id="2-关联关系"><a href="#2-关联关系" class="headerlink" title="2. 关联关系"></a>2. 关联关系</h4><p><strong>关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。</strong> </p>
<p>一般关联可以是双向的，也可以是单向的。在 UML 类图中，双向的关联可以用带两个箭头或者没有箭头的实线来表示，单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类。也可以在关联线的两端标注角色名，代表两种不同的角色。</p>
<p>在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系。图中所示是老师和学生的关系图，每个老师可以教多个学生，每个学生也可向多个老师学，他们是双向关联。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E4%B8%80%E8%88%AC%E5%85%B3%E8%81%94.gif"></p>
<h4 id="3-聚合关系"><a href="#3-聚合关系" class="headerlink" title="3. 聚合关系"></a>3. 聚合关系</h4><p>聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。</p>
<p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。 </p>
<blockquote>
<p> 在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。图 6 所示是大学和教师的关系图。 </p>
</blockquote>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB.gif"></p>
<h4 id="4-组合关系"><a href="#4-组合关系" class="headerlink" title="4.组合关系"></a>4.组合关系</h4><p>组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。</p>
<p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。 </p>
<blockquote>
<p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。图 7 所示是头和嘴的关系图。 </p>
</blockquote>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.gif"></p>
<h4 id="5-泛化关系"><a href="#5-泛化关系" class="headerlink" title="5.泛化关系"></a>5.泛化关系</h4><p>泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。 </p>
<blockquote>
<p> 在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类 .</p>
</blockquote>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E6%B3%9B%E5%8D%8E%E5%85%B3%E7%B3%BB.gif"></p>
<h4 id="6-实现关系"><a href="#6-实现关系" class="headerlink" title="6.实现关系"></a>6.实现关系</h4><p>实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。 </p>
<blockquote>
<p> 在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具 。</p>
</blockquote>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB.gif"></p>
<p><strong>UML中的类的关系图</strong></p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/UML%E4%B8%AD%E7%9A%84%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.gif"></p>
<p><strong>例：</strong></p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/UML%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E5%AE%9E%E4%BE%8B%E5%9B%BE.gif"></p>
<h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><h3 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a>1、开闭原则（Open Close Principle）</h3><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p>
<p>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。 </p>
<blockquote>
<p><strong>例如： Windows 的桌面主题设计。</strong></p>
<p>Windows 的主题是桌面背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的桌面主题，也可以从网上下载新的主题。这些主题有共同的特点，可以为其定义一个抽象类（Abstract Subject），而每个具体的主题（Specific Subject）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p>
</blockquote>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/Windows%E4%B8%BB%E9%A2%98%E8%AE%BE%E8%AE%A1.gif"></p>
<h3 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a>2、里氏代换原则（Liskov Substitution Principle）</h3><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。</strong>  </p>
<p>子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。 </p>
<blockquote>
<p><strong>例如：几维鸟不是鸟</strong></p>
<p>取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。 </p>
</blockquote>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%87%A0%E7%BB%B4%E9%B8%9F%E4%B8%8D%E6%98%AF%E9%B8%9F.gif"></p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%87%A0%E7%BB%B4%E9%B8%9F%E6%98%AF%E5%8A%A8%E7%89%A9.gif"></p>
<h3 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h3><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p>由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。</p>
<p>使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。 </p>
<p><strong>依赖倒置原则的主要作用如下</strong></p>
<ul>
<li>依赖倒置原则可以降低类间的耦合性。</li>
<li>依赖倒置原则可以提高系统的稳定性。</li>
<li>依赖倒置原则可以减少<strong>并行开发</strong>引起的风险。</li>
<li>依赖倒置原则可以提高代码的可读性和可维护性。</li>
</ul>
<blockquote>
<p><strong>例如： 顾客购物程序</strong> </p>
<pre><code class="java">//顾客从Shop1买东西
class Customer
&#123;
 public void shopping(Shop1 shop)
 &#123;
     //购物
     System.out.println（shop.sell());
 &#125;
&#125;
//顾客要从Shop2买东西，就得修改顾客的代码
class Customer
&#123;
 public void shopping(Shop2 shop)
 &#123;
     //购物
     System.out.println(shop.sell());
 &#125;
&#125;</code></pre>
<p>顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。解决方法是：定义“Shop1”和“Shop2”的共同接口 Shop，顾客类面向该接口编程。</p>
<pre><code class="java">public class test&#123;
    public static void main(String[] args)&#123;
         Customer wang=new Customer();
         System.out.println(&quot;顾客购买以下商品：&quot;); 
         wang.shopping(new ShaoguanShop()); 
         wang.shopping(new WuyuanShop());
     &#125;
&#125;
//Shop
interface Shop&#123;
    public String sell(); //卖
&#125;
//Shop1
class Shop1 implements Shop&#123;
    public String sell()&#123;
     return &quot;//Shop1&quot;; 
    &#125; 
&#125;
//Shop2
class Shop2 implements Shop&#123;
    public String sell()&#123;
        return &quot;Shop2&quot;; 
    &#125;
&#125; 
//顾客
class Customer&#123;
    public void shopping(Shop shop)&#123;
    //购物
    System.out.println(shop.sell()); 
    &#125;
&#125;</code></pre>
</blockquote>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E9%A1%BE%E5%AE%A2%E8%B4%AD%E7%89%A9%E7%A8%8B%E5%BA%8F.gif"></p>
<h3 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a>4、接口隔离原则（Interface Segregation Principle）</h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p><strong>接口隔离原则是为了约束接口、降低类对接口的依赖性</strong> 遵循接口隔离原则有以下 5 个优点 ：</p>
<ol>
<li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li>
<li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li>
<li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li>
<li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li>
<li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li>
</ol>
<blockquote>
<p>例如： 学生成绩管理程序 </p>
<p>学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均分、打印成绩信息、査询成绩信息等功能，如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中 。</p>
<pre><code class="java">package principle;
public class ISPtest
&#123;
 public static void main(String[] args)
 &#123;
     InputModule input =StuScoreList.getInputModule();
     CountModule count =StuScoreList.getCountModule();
     PrintModule print =StuScoreList.getPrintModule();
     input.insert();
     count.countTotalScore();
     print.printStuInfo();
     //print.delete();
 &#125;
&#125;
//输入模块接口
interface InputModule
&#123;
 void insert();
 void delete();
 void modify();
&#125;
//统计模块接口
interface CountModule
&#123;
 void countTotalScore();
 void countAverage();
&#125;
//打印模块接口
interface PrintModule
&#123;
 void printStuInfo();
 void queryStuInfo();
&#125;
//实现类
class StuScoreList implements InputModule,CountModule,PrintModule
&#123;
 private StuScoreList()&#123;&#125;
 public static InputModule getInputModule()
 &#123;
     return (InputModule)new StuScoreList();
 &#125;
 public static CountModule getCountModule()
 &#123;
     return (CountModule)new StuScoreList();
 &#125;
 public static PrintModule getPrintModule()
 &#123;
     return (PrintModule)new StuScoreList();
 &#125;
 public void insert()
 &#123;
     System.out.println(&quot;输入模块的insert()方法被调用！&quot;);
 &#125;
 public void delete()
 &#123;
     System.out.println(&quot;输入模块的delete()方法被调用！&quot;);
 &#125;
 public void modify()
 &#123;
     System.out.println(&quot;输入模块的modify()方法被调用！&quot;);
 &#125;
 public void countTotalScore()
 &#123;
     System.out.println(&quot;统计模块的countTotalScore()方法被调用！&quot;);
 &#125;
 public void countAverage()
 &#123;
     System.out.println(&quot;统计模块的countAverage()方法被调用！&quot;);
 &#125;
 public void printStuInfo()
 &#123;
     System.out.println(&quot;打印模块的printStuInfo()方法被调用！&quot;);
 &#125;
 public void queryStuInfo()
 &#123;
     System.out.println(&quot;打印模块的queryStuInfo()方法被调用！&quot;);
 &#125;
&#125;</code></pre>
</blockquote>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%B1%BB%E5%9B%BE.gif"></p>
<h3 id="5、迪米特法则，又称最少知道原则（Demeter-Principle）"><a href="#5、迪米特法则，又称最少知道原则（Demeter-Principle）" class="headerlink" title="5、迪米特法则，又称最少知道原则（Demeter Principle）"></a>5、迪米特法则，又称最少知道原则（Demeter Principle）</h3><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>如果两个软件实体无须直接通信( 存在关联、聚合或组合关系 )，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</strong> </p>
<p><strong>注意：</strong></p>
<ol>
<li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li>
<li>在类的结构设计上，尽量降低类成员的访问权限。</li>
<li>在类的设计上，优先考虑将一个类设置成不变类。</li>
<li>在对其他类的引用上，将引用其他对象的次数降到最低。</li>
<li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li>
<li>谨慎使用序列化（Serializable）功能。</li>
</ol>
<blockquote>
<p><strong>例如： 明星与经纪人的关系实例</strong> </p>
<p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则 。</p>
<pre><code class="java">public class LoDtest
&#123;
 public static void main(String[] args)
 &#123;
     Agent agent=new Agent();
     agent.setStar(new Star(&quot;林心如&quot;));
     agent.setFans(new Fans(&quot;粉丝韩丞&quot;));
     agent.setCompany(new Company(&quot;中国传媒有限公司&quot;));
     agent.meeting();
     agent.business();
 &#125;
&#125;
//经纪人
class Agent
&#123;
 private Star myStar;
 private Fans myFans;
 private Company myCompany;
 public void setStar(Star myStar)
 &#123;
     this.myStar=myStar;
 &#125;
 public void setFans(Fans myFans)
 &#123;
     this.myFans=myFans;
 &#125;
 public void setCompany(Company myCompany)
 &#123;
     this.myCompany=myCompany;
 &#125;
 public void meeting()
 &#123;
     System.out.println(myFans.getName()+&quot;与明星&quot;+myStar.getName()+&quot;见面了。&quot;);
 &#125;
 public void business()
 &#123;
     System.out.println(myCompany.getName()+&quot;与明星&quot;+myStar.getName()+&quot;洽淡业务。&quot;);
 &#125;
&#125;
//明星
class Star
&#123;
 private String name;
 Star(String name)
 &#123;
     this.name=name;
 &#125;
 public String getName()
 &#123;
     return name;
 &#125;
&#125;
//粉丝
class Fans
&#123;
 private String name;
 Fans(String name)
 &#123;
     this.name=name;
 &#125;
 public String getName()
 &#123;
     return name;
 &#125;
&#125;
//媒体公司
class Company
&#123;
 private String name;
 Company(String name)
 &#123;
     this.name=name;
 &#125;
 public String getName()
 &#123;
     return name;
 &#125;
&#125;</code></pre>
</blockquote>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E6%98%8E%E6%98%9F%E4%B8%8E%E7%BB%8F%E7%BA%AA%E4%BA%BA%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.gif"></p>
<h3 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h3><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。 </p>
<p><strong>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</strong> </p>
<blockquote>
<p>**例如： 汽车分类管理程序 **</p>
<p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。下图所示是用继承：关系实现的汽车分类的类图。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%94%A8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B1%BD%E8%BD%A6%E5%88%86%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9B%BE.gif"></p>
<p>可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如下图所示。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%94%A8%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B1%BD%E8%BD%A6%E5%88%86%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9B%BE.gif"></p>
</blockquote>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的主要关注点是“<strong>怎样创建对象？</strong>”，它的主要特点是“<strong>将对象的创建与使用分离</strong>”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。 </p>
<h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><p>单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。</p>
<p>单例模式有 3 个特点：</p>
<ol>
<li>单例类只有一个实例对象；</li>
<li>该单例对象必须由单例类自行创建；</li>
<li>单例类对外提供一个访问该单例的全局访问点；</li>
</ol>
<p>单例模式是设计模式中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p>
<h4 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a>单例模式的结构</h4><ul>
<li>单例类：包含一个实例且能自行创建这个实例的类。</li>
<li>访问类：使用单例的类。</li>
</ul>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h4 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h4><h5 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h5><p>该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。 </p>
<pre><code class="java">public class LazySingleton
&#123;
    private static volatile LazySingleton instance=null;    //保证 instance 在所有线程中同步
    private LazySingleton()&#123;&#125;    //private 避免类在外部被实例化
    public static synchronized LazySingleton getInstance()
    &#123;
        //getInstance 方法前加同步
        if(instance==null)
        &#123;
            instance=new LazySingleton();
        &#125;
        return instance;
    &#125;
&#125;</code></pre>
<blockquote>
<p>如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。 </p>
</blockquote>
<h5 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h5><p>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。 </p>
<pre><code class="java">public class HungrySingleton
&#123;
    private static final HungrySingleton instance=new HungrySingleton();
    private HungrySingleton()&#123;&#125;
    public static HungrySingleton getInstance()
    &#123;
        return instance;
    &#125;
&#125;</code></pre>
<blockquote>
<p> 饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。 </p>
</blockquote>
<h4 id="单例模式的应用实例"><a href="#单例模式的应用实例" class="headerlink" title="单例模式的应用实例"></a>单例模式的应用实例</h4><p><strong>用懒汉式单例模式模拟产生美国当今总统对象</strong> </p>
<p>在每一届任期内，美国的总统只有一人，所以本实例适合用单例模式实现，图 2 所示是用懒汉式单例实现的结构图。</p>
 <img src="https://gitee.com/bigpaozz/img_md/raw/master/美国总统生成器的结构图.gif" style="zoom:120%;" />

<pre><code class="java">public class SingletonLazy
&#123;
    public static void main(String[] args)
    &#123;
        President zt1=President.getInstance();
        zt1.getName();    //输出总统的名字
        President zt2=President.getInstance();
        zt2.getName();    //输出总统的名字
        if(zt1==zt2)
        &#123;
           System.out.println(&quot;他们是同一人！&quot;);
        &#125;
        else
        &#123;
           System.out.println(&quot;他们不是同一人！&quot;);
        &#125;
    &#125;
&#125;

class President
&#123;
    private static volatile President instance=null;    //保证instance在所有线程中同步
    //private避免类在外部被实例化
    private President()
    &#123;
        System.out.println(&quot;产生一个总统！&quot;);
    &#125;
    public static synchronized President getInstance()
    &#123;
        //在getInstance方法上加同步
        if(instance==null)
        &#123;
               instance=new President();
        &#125;
        else
        &#123;
           System.out.println(&quot;已经有一个总统，不能产生新总统！&quot;);
        &#125;
        return instance;
    &#125;
    public void getName()
    &#123;
        System.out.println(&quot;我是美国总统：特朗普。&quot;);
    &#125;  
&#125;</code></pre>
<p><strong>用饿汉式单例模式模拟产生猪八戒对象</strong> </p>
<p>同上例类似，猪八戒也只有一个，所以本实例同样适合用单例模式实现。本实例由于要显示猪八戒的图像，所以用到了框架窗体 JFrame 组件，这里的猪八戒类是单例类，可以将其定义成面板 JPanel 的子类，里面包含了标签，用于保存猪八戒的图像，客户窗体可以获得猪八戒对象，并显示它。图 3 所示是用饿汉式单例实现的结构图。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%8C%AA%E5%85%AB%E6%88%92%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">import java.awt.*;
import javax.swing.*;
public class SingletonEager
&#123;
    public static void main(String[] args)
    &#123;
        JFrame jf=new JFrame(&quot;饿汉单例模式测试&quot;);
        jf.setLayout(new GridLayout(1,2));
        Container contentPane=jf.getContentPane();
        Bajie obj1=Bajie.getInstance();
        contentPane.add(obj1);    
        Bajie obj2=Bajie.getInstance(); 
        contentPane.add(obj2);
        if(obj1==obj2)
        &#123;
            System.out.println(&quot;他们是同一人！&quot;);
        &#125;
        else
        &#123;
            System.out.println(&quot;他们不是同一人！&quot;);
        &#125;   
        jf.pack();       
        jf.setVisible(true);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;
&#125;
class Bajie extends JPanel
&#123;
    private static Bajie instance=new Bajie();
    private Bajie()
    &#123; 
        JLabel l1=new JLabel(new ImageIcon(&quot;src/Bajie.jpg&quot;));
        this.add(l1);   
    &#125;
    public static Bajie getInstance()
    &#123;
        return instance;
    &#125;
&#125;</code></pre>
<h4 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a>单例模式的应用场景</h4><ul>
<li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li>
<li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li>
<li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li>
</ul>
<h4 id="单例模式的扩展"><a href="#单例模式的扩展" class="headerlink" title="单例模式的扩展"></a>单例模式的扩展</h4><p>单例模式可扩展为有限的多例（Multitcm）模式，这种模式可生成有限个实例并保存在 ArmyList 中，客户需要时可随机获取 .</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E6%9C%89%E9%99%90%E7%9A%84%E5%A4%9A%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h3 id="2-原型模式"><a href="#2-原型模式" class="headerlink" title="2.原型模式"></a>2.原型模式</h3><p>在有些系统中，存在大量相同或相似对象的创建问题，如果用传统的构造函数来创建对象，会比较复杂且耗时耗资源，用原型模式生成对象就很高效 。</p>
<p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。 </p>
<h4 id="原型模式的结构与实现"><a href="#原型模式的结构与实现" class="headerlink" title="原型模式的结构与实现"></a>原型模式的结构与实现</h4><p> 由于Java提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。 </p>
<h5 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h5><ol>
<li>抽象原型类：规定了具体原型对象必须实现的接口。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h5><p>原型模式的克隆分为浅克隆和深克隆，Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。 </p>
<pre><code class="java">//具体原型类
class Realizetype implements Cloneable
&#123;
    Realizetype()
    &#123;
        System.out.println(&quot;具体原型创建成功！&quot;);
    &#125;
    public Object clone() throws CloneNotSupportedException
    &#123;
        System.out.println(&quot;具体原型复制成功！&quot;);
        return (Realizetype)super.clone();
    &#125;
&#125;
//原型模式的测试类
public class PrototypeTest
&#123;
    public static void main(String[] args)throws CloneNotSupportedException
    &#123;
        Realizetype obj1=new Realizetype();
        Realizetype obj2=(Realizetype)obj1.clone();
        System.out.println(&quot;obj1==obj2?&quot;+(obj1==obj2));
    &#125;
&#125;

&gt; 具体原型创建成功！
&gt; 具体原型复制成功！
&gt; obj1==obj2?false</code></pre>
<h4 id="原型模式的应用实例"><a href="#原型模式的应用实例" class="headerlink" title="原型模式的应用实例"></a>原型模式的应用实例</h4><p><strong>用原型模式模拟“孙悟空”复制自己</strong> </p>
<p>孙悟空拔下猴毛轻轻一吹就变出很多孙悟空，这实际上是用到了原型模式。这里的孙悟空类 SunWukong 是具体原型类，而 Java 中的 Cloneable 接口是抽象原型类。</p>
<p>同前面介绍的猪八戒实例一样，由于要显示孙悟空的图像，所以将孙悟空类定义成面板 JPanel 的子类，里面包含了标签，用于保存孙悟空的图像。</p>
<p>另外，重写了 Cloneable 接口的 clone() 方法，用于复制新的孙悟空。访问类可以通过调用孙悟空的 clone() 方法复制多个孙悟空，并在框架窗体 JFrame 中显示。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AD%99%E6%82%9F%E7%A9%BA%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">import java.awt.*;
import javax.swing.*;
class SunWukong extends JPanel implements Cloneable
&#123;
    private static final long serialVersionUID = 5543049531872119328L;
    public SunWukong()
    &#123;
        JLabel l1=new JLabel(new ImageIcon(&quot;src/Wukong.jpg&quot;));
        this.add(l1);   
    &#125;
    public Object clone()
    &#123;
        SunWukong w=null;
        try
        &#123;
            w=(SunWukong)super.clone();
        &#125;
        catch(CloneNotSupportedException e)
        &#123;
            System.out.println(&quot;拷贝悟空失败!&quot;);
        &#125;
        return w;
    &#125;
&#125;
public class ProtoTypeWukong
&#123;
    public static void main(String[] args)
    &#123;
        JFrame jf=new JFrame(&quot;原型模式测试&quot;);
        jf.setLayout(new GridLayout(1,2));
        Container contentPane=jf.getContentPane();
        SunWukong obj1=new SunWukong();
        contentPane.add(obj1);       
        SunWukong obj2=(SunWukong)obj1.clone();
        contentPane.add(obj2);   
        jf.pack();       
        jf.setVisible(true);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);   
    &#125;
&#125;</code></pre>
<p><strong>用原型模式生成“三好学生”奖状</strong> </p>
<p>同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，属于相似对象的复制，同样可以用原型模式创建，然后再做简单修改就可以了。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A5%96%E7%8A%B6%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">public class ProtoTypeCitation
&#123;
    public static void main(String[] args) throws CloneNotSupportedException
    &#123;
        citation obj1=new citation(&quot;张三&quot;,&quot;同学：在2016学年第一学期中表现优秀，被评为三好学生。&quot;,&quot;韶关学院&quot;);
        obj1.display();
        citation obj2=(citation) obj1.clone();
        obj2.setName(&quot;李四&quot;); 
        obj2.display();
    &#125;
&#125;
//奖状类
class citation implements Cloneable
&#123;
    String name;
    String info;
    String college;
    citation(String name,String info,String college)
    &#123;
        this.name=name;
        this.info=info;
        this.college=college;
        System.out.println(&quot;奖状创建成功！&quot;);
    &#125;
    void setName(String name)
    &#123;
        this.name=name;
    &#125;
    String getName()
    &#123;
        return(this.name);
    &#125;
    void display()
    &#123;
        System.out.println(name+info+college);
    &#125;
    public Object clone() throws CloneNotSupportedException
    &#123;
        System.out.println(&quot;奖状拷贝成功！&quot;);
        return (citation)super.clone();
    &#125;
&#125;

&gt; 奖状创建成功！
&gt; 张三同学：在2016学年第一学期中表现优秀，被评为三好学生。韶关学院
&gt; 奖状拷贝成功！
&gt; 李四同学：在2016学年第一学期中表现优秀，被评为三好学生。韶关学院</code></pre>
<h4 id="原型模式的应用场景"><a href="#原型模式的应用场景" class="headerlink" title="原型模式的应用场景"></a>原型模式的应用场景</h4><ul>
<li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li>
<li>对象的创建过程比较麻烦，但复制比较简单的时候。</li>
</ul>
<h4 id="原型模式的扩展"><a href="#原型模式的扩展" class="headerlink" title="原型模式的扩展"></a>原型模式的扩展</h4><p>原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%B8%A6%E5%8E%9F%E5%9E%8B%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<p><strong>用带原型管理器的原型模式来生成包含“圆”和“正方形”等图形的原型，并计算其面积</strong> </p>
<p>本实例中由于存在不同的图形类，例如，“圆”和“正方形”，它们计算面积的方法不一样，所以需要用一个原型管理器来管理它们 。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%9B%BE%E5%BD%A2%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">import java.util.*;
interface Shape extends Cloneable
&#123;
    public Object clone();    //拷贝
    public void countArea();    //计算面积
&#125;
class Circle implements Shape
&#123;
    public Object clone()
    &#123;
        Circle w=null;
        try
        &#123;
            w=(Circle)super.clone();
        &#125;
        catch(CloneNotSupportedException e)
        &#123;
            System.out.println(&quot;拷贝圆失败!&quot;);
        &#125;
        return w;
    &#125;
    public void countArea()
    &#123;
        int r=0;
        System.out.print(&quot;这是一个圆，请输入圆的半径：&quot;);
        Scanner input=new Scanner(System.in);
        r=input.nextInt();
        System.out.println(&quot;该圆的面积=&quot;+3.1415*r*r+&quot;\n&quot;);
    &#125;
&#125;
class Square implements Shape
&#123;
    public Object clone()
    &#123;
        Square b=null;
        try
        &#123;
            b=(Square)super.clone();
        &#125;
        catch(CloneNotSupportedException e)
        &#123;
            System.out.println(&quot;拷贝正方形失败!&quot;);
        &#125;
        return b;
    &#125;
    public void countArea()
    &#123;
        int a=0;
        System.out.print(&quot;这是一个正方形，请输入它的边长：&quot;);
        Scanner input=new Scanner(System.in);
        a=input.nextInt();
        System.out.println(&quot;该正方形的面积=&quot;+a*a+&quot;\n&quot;);
    &#125;
&#125;
class ProtoTypeManager
&#123;
    private HashMap&lt;String, Shape&gt;ht=new HashMap&lt;String,Shape&gt;(); 
    public ProtoTypeManager()
    &#123;
        ht.put(&quot;Circle&quot;,new Circle());
           ht.put(&quot;Square&quot;,new Square());
    &#125; 
    public void addshape(String key,Shape obj)
    &#123;
        ht.put(key,obj);
    &#125;
    public Shape getShape(String key)
    &#123;
        Shape temp=ht.get(key);
        return (Shape) temp.clone();
    &#125;
&#125;
public class ProtoTypeShape
&#123;
    public static void main(String[] args)
    &#123;
        ProtoTypeManager pm=new ProtoTypeManager();    
        Shape obj1=(Circle)pm.getShape(&quot;Circle&quot;);
        obj1.countArea();          
        Shape obj2=(Shape)pm.getShape(&quot;Square&quot;);
        obj2.countArea();     
    &#125;
&#125;

&gt; 这是一个圆，请输入圆的半径：3
&gt; 该圆的面积=28.2735
&gt; 这是一个正方形，请输入它的边长：3
&gt; 该正方形的面积=9</code></pre>
<h3 id="3-工厂方法模式"><a href="#3-工厂方法模式" class="headerlink" title="3.工厂方法模式"></a>3.工厂方法模式</h3><p>在现实生活中社会分工越来越细，越来越专业化。各种产品有专门的工厂生产，彻底告别了自给自足的小农经济时代，这大大缩短了产品的生产周期，提高了生产效率。 </p>
<h4 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h4><p>工厂方法（FactoryMethod）模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p>
<p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。 </p>
<p>工厂方法模式的主要优点有：</p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li>
</ul>
<p>其缺点是：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</p>
<h4 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><h5 id="1-模式的结构"><a href="#1-模式的结构" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现"><a href="#2-模式的实现" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package FactoryMethod;
public class AbstractFactoryTest&#123;
    public static void main(String[] args)&#123;
        try&#123;
            Product a;
            AbstractFactory af;
            af=(AbstractFactory) ReadXML1.getObject();
            a=af.newProduct();
            a.show();
        &#125;catch(Exception e)&#123;
            System.out.println(e.getMessage());
        &#125;
    &#125;
&#125;
//抽象产品：提供了产品的接口
interface Product&#123;
    public void show();
&#125;
//具体产品1：实现抽象产品中的抽象方法
class ConcreteProduct1 implements Product&#123;
    public void show()&#123;
        System.out.println(&quot;具体产品1显示...&quot;);
    &#125;
&#125;
//具体产品2：实现抽象产品中的抽象方法
class ConcreteProduct2 implements Product&#123;
    public void show()&#123;
        System.out.println(&quot;具体产品2显示...&quot;);
    &#125;
&#125;
//抽象工厂：提供了厂品的生成方法
interface AbstractFactory&#123;
    public Product newProduct();
&#125;
//具体工厂1：实现了厂品的生成方法
class ConcreteFactory1 implements AbstractFactory&#123;
    public Product newProduct()&#123;
        System.out.println(&quot;具体工厂1生成--&gt;具体产品1...&quot;);
        return new ConcreteProduct1();
    &#125;
&#125;
//具体工厂2：实现了厂品的生成方法
class ConcreteFactory2 implements AbstractFactory&#123;
    public Product newProduct()&#123;
        System.out.println(&quot;具体工厂2生成--&gt;具体产品2...&quot;);
        return new ConcreteProduct2();
    &#125;
&#125;</code></pre>
<h3 id="4-抽象工厂模式"><a href="#4-抽象工厂模式" class="headerlink" title="4.抽象工厂模式"></a>4.抽象工厂模式</h3><p>同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品 ，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。  </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%94%B5%E5%99%A8%E5%B7%A5%E5%8E%82%E7%9A%84%E4%BA%A7%E5%93%81%E7%AD%89%E7%BA%A7%E4%B8%8E%E4%BA%A7%E5%93%81%E6%97%8F.gif"></p>
<h4 id="模式的定义与特点-1"><a href="#模式的定义与特点-1" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h4><p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。 </p>
<p>工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。 </p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>
</ul>
<p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p>
<ul>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>
<li>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</li>
</ul>
<p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。 </p>
<h4 id="模式的结构与实现-1"><a href="#模式的结构与实现-1" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><p>抽象工厂模式同工厂方法模式一样，也是由<strong>抽象工厂、具体工厂、抽象产品和具体产品</strong>等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。</p>
<h5 id="1-模式的结构-1"><a href="#1-模式的结构-1" class="headerlink" title="1.模式的结构"></a>1.模式的结构</h5><ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含创建多个产品的方法 newProduct()，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-1"><a href="#2-模式的实现-1" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><p>(1) 抽象工厂：提供了产品的生成方法。 </p>
<pre><code class="java">interface AbstractFactory
&#123;
    public Product1 newProduct1();
    public Product2 newProduct2();
&#125;</code></pre>
<p>(2) 具体工厂：实现了产品的生成方法。 </p>
<pre><code class="java">class ConcreteFactory1 implements AbstractFactory
&#123;
    public Product1 newProduct1()
    &#123;
        System.out.println(&quot;具体工厂 1 生成--&gt;具体产品 11...&quot;);
        return new ConcreteProduct11();
    &#125;
    public Product2 newProduct2()
    &#123;
        System.out.println(&quot;具体工厂 1 生成--&gt;具体产品 21...&quot;);
        return new ConcreteProduct21();
    &#125;
&#125;</code></pre>
<h4 id="模式的应用实例"><a href="#模式的应用实例" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h4><p> <strong>用抽象工厂模式设计农场类</strong> </p>
<p>农场中除了像畜牧场一样可以养动物，还可以培养植物，如养马、养牛、种菜、种水果等，所以本实例比前面介绍的畜牧场类复杂，必须用抽象工厂模式来实现。 </p>
<p>本例用抽象工厂模式来设计两个农场，一个是韶关农场用于养牛和种菜，一个是上饶农场用于养马和种水果，可以在以上两个农场中定义一个生成动物的方法 newAnimal() 和一个培养植物的方法 newPlant()。 </p>
<p>对马类、牛类、蔬菜类和水果类等具体产品类，由于要显示它们的图像，所以它们的构造函数中用到了 JPanel、JLabel 和 ImageIcon 等组件，并定义一个 show() 方法来显示它们。 </p>
<p>客户端程序通过对象生成器类 ReadXML 读取 XML 配置文件中的数据来决定养什么动物和培养什么植物。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%86%9C%E5%9C%BA%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package AbstractFactory;
import java.awt.*;
import javax.swing.*;
public class FarmTest
&#123;
    public static void main(String[] args)
    &#123;
        try
        &#123;          
            Farm f;
            Animal a;
            Plant p;
            f=(Farm) ReadXML.getObject();
            a=f.newAnimal();
            p=f.newPlant();
            a.show();
            p.show();
        &#125;
        catch(Exception e)
        &#123;
            System.out.println(e.getMessage());
        &#125;
    &#125;
&#125;
//抽象产品：动物类
interface Animal
&#123;
    public void show();
&#125;
//具体产品：马类
class Horse implements Animal
&#123;
    JScrollPane sp;
    JFrame jf=new JFrame(&quot;抽象工厂模式测试&quot;);
    public Horse()
    &#123;
        Container contentPane=jf.getContentPane();
        JPanel p1=new JPanel();
        p1.setLayout(new GridLayout(1,1));
        p1.setBorder(BorderFactory.createTitledBorder(&quot;动物：马&quot;));
        sp=new JScrollPane(p1);
        contentPane.add(sp, BorderLayout.CENTER);
        JLabel l1=new JLabel(new ImageIcon(&quot;src/A_Horse.jpg&quot;));
        p1.add(l1);       
        jf.pack();       
        jf.setVisible(false);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//用户点击窗口关闭 
    &#125;
    public void show()
    &#123;
        jf.setVisible(true);
    &#125;
&#125;
//具体产品：牛类
class Cattle implements Animal
&#123;
    JScrollPane sp;
    JFrame jf=new JFrame(&quot;抽象工厂模式测试&quot;);
    public Cattle() &#123;
        Container contentPane=jf.getContentPane();
        JPanel p1=new JPanel();
        p1.setLayout(new GridLayout(1,1));
        p1.setBorder(BorderFactory.createTitledBorder(&quot;动物：牛&quot;));
        sp=new JScrollPane(p1);
        contentPane.add(sp, BorderLayout.CENTER);
        JLabel l1=new JLabel(new ImageIcon(&quot;src/A_Cattle.jpg&quot;));
        p1.add(l1);       
        jf.pack();       
        jf.setVisible(false);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//用户点击窗口关闭 
    &#125;
    public void show()
    &#123;
        jf.setVisible(true);
    &#125;
&#125;
//抽象产品：植物类
interface Plant
&#123;
    public void show();
&#125;
//具体产品：水果类
class Fruitage implements Plant
&#123;
    JScrollPane sp;
    JFrame jf=new JFrame(&quot;抽象工厂模式测试&quot;);
    public Fruitage()
    &#123;
        Container contentPane=jf.getContentPane();
        JPanel p1=new JPanel();
        p1.setLayout(new GridLayout(1,1));
        p1.setBorder(BorderFactory.createTitledBorder(&quot;植物：水果&quot;));
        sp=new JScrollPane(p1);
        contentPane.add(sp, BorderLayout.CENTER);
        JLabel l1=new JLabel(new ImageIcon(&quot;src/P_Fruitage.jpg&quot;));
        p1.add(l1);       
        jf.pack();       
        jf.setVisible(false);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//用户点击窗口关闭 
    &#125;
    public void show()
    &#123;
        jf.setVisible(true);
    &#125;
&#125;
//具体产品：蔬菜类
class Vegetables implements Plant
&#123;
    JScrollPane sp;
    JFrame jf=new JFrame(&quot;抽象工厂模式测试&quot;);
    public Vegetables()
    &#123;
        Container contentPane=jf.getContentPane();
        JPanel p1=new JPanel();
        p1.setLayout(new GridLayout(1,1));
        p1.setBorder(BorderFactory.createTitledBorder(&quot;植物：蔬菜&quot;));
        sp=new JScrollPane(p1);
        contentPane.add(sp, BorderLayout.CENTER);
        JLabel l1=new JLabel(new ImageIcon(&quot;src/P_Vegetables.jpg&quot;));
        p1.add(l1);       
        jf.pack();       
        jf.setVisible(false);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//用户点击窗口关闭 
    &#125;
    public void show()
    &#123;
        jf.setVisible(true);
    &#125;
&#125;
//抽象工厂：农场类
interface Farm
&#123;
    public Animal newAnimal();
    public Plant newPlant();
&#125;
//具体工厂：韶关农场类
class SGfarm implements Farm
&#123;
    public Animal newAnimal()
    &#123;
        System.out.println(&quot;新牛出生！&quot;);
        return new Cattle();
    &#125;
    public Plant newPlant()
    &#123;
        System.out.println(&quot;蔬菜长成！&quot;);
        return new Vegetables();
    &#125;
&#125;
//具体工厂：上饶农场类
class SRfarm implements Farm
&#123;
    public Animal newAnimal()
    &#123;
        System.out.println(&quot;新马出生！&quot;);
        return new Horse();
    &#125;
    public Plant newPlant()
    &#123;
        System.out.println(&quot;水果长成！&quot;);
        return new Fruitage();
    &#125;
&#125;</code></pre>
<pre><code class="java">package AbstractFactory;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import java.io.*;
class ReadXML
&#123;
    public static Object getObject()
    &#123;
        try
        &#123;
            DocumentBuilderFactory dFactory=DocumentBuilderFactory.newInstance();
            DocumentBuilder builder=dFactory.newDocumentBuilder();
            Document doc;                           
            doc=builder.parse(new File(&quot;src/AbstractFactory/config.xml&quot;));
            NodeList nl=doc.getElementsByTagName(&quot;className&quot;);
            Node classNode=nl.item(0).getFirstChild();
            String cName=&quot;AbstractFactory.&quot;+classNode.getNodeValue();
            System.out.println(&quot;新类名：&quot;+cName);
            Class&lt;?&gt; c=Class.forName(cName);
              Object obj=c.newInstance();
            return obj;
        &#125;  
        catch(Exception e)
        &#123;
               e.printStackTrace();
               return null;
        &#125;
    &#125;
&#125;</code></pre>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;config&gt;
    &lt;className&gt;SGfarm&lt;/className&gt;
&lt;/config&gt;</code></pre>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%86%9C%E5%9C%BA%E5%85%BB%E6%AE%96%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg"></p>
<h4 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h4><ol>
<li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</li>
<li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</li>
<li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li>
</ol>
<h4 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h4><p>抽象工厂模式的扩展有一定的“开闭原则”倾斜性：</p>
<ol>
<li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li>
<li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。</li>
</ol>
<p>另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。 </p>
<h3 id="5-建造者模式（Bulider模式）"><a href="#5-建造者模式（Bulider模式）" class="headerlink" title="5.建造者模式（Bulider模式）"></a>5.建造者模式（Bulider模式）</h3><p>产品是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。 </p>
<h4 id="模式的定义与特点-2"><a href="#模式的定义与特点-2" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h4><p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。 </p>
<p>该模式的主要优点如下：</p>
<ol>
<li>各个具体的建造者相互独立，有利于系统的扩展。</li>
<li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li>
</ol>
<p>其缺点如下：</p>
<ol>
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，该模式会增加很多的建造者类。</li>
</ol>
<p>建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。 </p>
<h4 id="模式的结构与实现-2"><a href="#模式的结构与实现-2" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><h5 id="1-模式的结构-2"><a href="#1-模式的结构-2" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个部件。</li>
<li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li>
<li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li>
<li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-2"><a href="#2-模式的实现-2" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><p>(1) 产品角色：包含多个组成部件的复杂对象。 </p>
<pre><code class="java">class Product
&#123;
    private String partA;
    private String partB;
    private String partC;
    public void setPartA(String partA)
    &#123;
        this.partA=partA;
    &#125;
    public void setPartB(String partB)
    &#123;
        this.partB=partB;
    &#125;
    public void setPartC(String partC)
    &#123;
        this.partC=partC;
    &#125;
    public void show()
    &#123;
        //显示产品的特性
    &#125;
&#125;</code></pre>
<p>(2) 抽象建造者：包含创建产品各个子部件的抽象方法。 </p>
<pre><code class="java">abstract class Builder
&#123;
    //创建产品对象
    protected Product product=new Product();
    public abstract void buildPartA();
    public abstract void buildPartB();
    public abstract void buildPartC();
    //返回产品对象
    public Product getResult()
    &#123;
        return product;
    &#125;
&#125;</code></pre>
<p>(3) 具体建造者：实现了抽象建造者接口。 </p>
<pre><code class="java">public class ConcreteBuilder extends Builder
&#123;
    public void buildPartA()
    &#123;
        product.setPartA(&quot;建造 PartA&quot;);
    &#125;
    public void buildPartB()
    &#123;
        product.setPartA(&quot;建造 PartB&quot;);
    &#125;
    public void buildPartC()
    &#123;
        product.setPartA(&quot;建造 PartC&quot;);
    &#125;
&#125;</code></pre>
<p>(4) 指挥者：调用建造者中的方法完成复杂对象的创建。 </p>
<pre><code class="java">class Director
&#123;
    private Builder builder;
    public Director(Builder builder)
    &#123;
        this.builder=builder;
    &#125;
    //产品构建与组装方法
    public Product construct()
    &#123;
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
        return builder.getResult();
    &#125;
&#125;</code></pre>
<p>(5) 客户类。 </p>
<pre><code class="java">public class Client
&#123;
    public static void main(String[] args)
    &#123;
        Builder builder=new ConcreteBuilder();
        Director director=new Director(builder);
        Product product=director.construct();
        product.show();
    &#125;
&#125;</code></pre>
<h4 id="模式的应用实例-1"><a href="#模式的应用实例-1" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h4><p>用建造者（Builder）模式描述客厅装修 </p>
<p>客厅装修是一个复杂的过程，它包含墙体的装修、电视机的选择、沙发的购买与布局等。客户把装修要求告诉项目经理，项目经理指挥装修工人一步步装修，最后完成整个客厅的装修与布局，所以本实例用建造者模式实现比较适合。</p>
<p>这里客厅是产品，包括墙、电视和沙发等组成部分。具体装修工人是具体建造者，他们负责装修与墙、电视和沙发的布局。项目经理是指挥者，他负责指挥装修工人进行装修。</p>
<p>另外，客厅类中提供了 show() 方法，可以将装修效果图显示出来。客户端程序通过对象生成器类 ReadXML 读取 XML 配置文件中的装修方案数据，调用项目经理进行装修 。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AE%A2%E5%8E%85%E8%A3%85%E4%BF%AE%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package Builder;
import java.awt.*;
import javax.swing.*;
public class ParlourDecorator
&#123;
    public static void main(String[] args)
    &#123;
        try
        &#123;
            Decorator d;
            d=(Decorator) ReadXML.getObject();
            ProjectManager m=new ProjectManager(d);       
            Parlour p=m.decorate();
            p.show();
        &#125;
        catch(Exception e)
        &#123;
            System.out.println(e.getMessage());
        &#125;
    &#125;
&#125;
//产品：客厅
class Parlour
&#123;
    private String wall;    //墙
    private String TV;    //电视
    private String sofa;    //沙发  
    public void setWall(String wall)
    &#123;
        this.wall=wall;
    &#125;
    public void setTV(String TV)
    &#123;
        this.TV=TV;
    &#125;
    public void setSofa(String sofa)
    &#123;
        this.sofa=sofa;
    &#125;   
    public void show()
    &#123;
        JFrame jf=new JFrame(&quot;建造者模式测试&quot;);
        Container contentPane=jf.getContentPane();
        JPanel p=new JPanel();   
        JScrollPane sp=new JScrollPane(p);  
        String parlour=wall+TV+sofa;
        JLabel l=new JLabel(new ImageIcon(&quot;src/&quot;+parlour+&quot;.jpg&quot;));
        p.setLayout(new GridLayout(1,1));
        p.setBorder(BorderFactory.createTitledBorder(&quot;客厅&quot;));
        p.add(l);
        contentPane.add(sp,BorderLayout.CENTER);       
        jf.pack();  
        jf.setVisible(true);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;   
&#125;
//抽象建造者：装修工人
abstract class Decorator
&#123;
    //创建产品对象
    protected  Parlour product=new Parlour();
    public  abstract void buildWall();
    public  abstract void buildTV();
    public  abstract void buildSofa();
    //返回产品对象
    public  Parlour getResult()
    &#123;
        return  product;
    &#125;
&#125;
//具体建造者：具体装修工人1
class ConcreteDecorator1  extends Decorator
&#123;
    public void buildWall()
    &#123;
        product.setWall(&quot;w1&quot;);
    &#125;
    public void buildTV()
    &#123;
        product.setTV(&quot;TV1&quot;);
    &#125;
    public void buildSofa()
    &#123;
        product.setSofa(&quot;sf1&quot;);
    &#125;
&#125;
//具体建造者：具体装修工人2
class ConcreteDecorator2 extends Decorator
&#123;
    public void buildWall()
    &#123;
        product.setWall(&quot;w2&quot;);
      &#125;
      public void buildTV()
      &#123;
          product.setTV(&quot;TV2&quot;);
      &#125;
      public void buildSofa()
      &#123;
          product.setSofa(&quot;sf2&quot;);
      &#125;
&#125;
//指挥者：项目经理
class ProjectManager
&#123;
    private Decorator builder;
    public ProjectManager(Decorator builder)
    &#123;
          this.builder=builder;
    &#125;
    //产品构建与组装方法
    public Parlour decorate()
    &#123;
          builder.buildWall();
        builder.buildTV();
        builder.buildSofa();
        return builder.getResult();
    &#125;
&#125;</code></pre>
<pre><code class="java">package Builder;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import java.io.*;
class ReadXML
&#123;
    public static Object getObject()
    &#123;
        try
        &#123;
            DocumentBuilderFactory dFactory=DocumentBuilderFactory.newInstance();
            DocumentBuilder builder=dFactory.newDocumentBuilder();
            Document doc;                           
            doc=builder.parse(new File(&quot;src/Builder/config.xml&quot;));
            NodeList nl=doc.getElementsByTagName(&quot;className&quot;);
            Node classNode=nl.item(0).getFirstChild();
            String cName=&quot;Builder.&quot;+classNode.getNodeValue();
            System.out.println(&quot;新类名：&quot;+cName);
            Class&lt;?&gt; c=Class.forName(cName);
              Object obj=c.newInstance();
            return obj;
         &#125;  
         catch(Exception e)
         &#123;
                   e.printStackTrace();
                   return null;
         &#125;
    &#125;
&#125;</code></pre>
<h4 id="模式的应用场景-1"><a href="#模式的应用场景-1" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h4><ul>
<li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li>
<li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li>
</ul>
<h4 id="模式的扩展-1"><a href="#模式的扩展-1" class="headerlink" title="模式的扩展"></a>模式的扩展</h4><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。 </p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<h3 id="1-代理（Proxy）模式"><a href="#1-代理（Proxy）模式" class="headerlink" title="1.代理（Proxy）模式"></a>1.代理（Proxy）模式</h3><p>在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。 </p>
<p> 在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。 </p>
<h4 id="代理模式的定义与特点"><a href="#代理模式的定义与特点" class="headerlink" title="代理模式的定义与特点"></a>代理模式的定义与特点</h4><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。 </p>
<p>代理模式的主要优点有：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul>
<p>其主要缺点是：</p>
<ul>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
</ul>
<h4 id="代理模式的结构与实现"><a href="#代理模式的结构与实现" class="headerlink" title="代理模式的结构与实现"></a>代理模式的结构与实现</h4><p>通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问。</p>
<h5 id="1-模式的结构-3"><a href="#1-模式的结构-3" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-3"><a href="#2-模式的实现-3" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package proxy;
public class ProxyTest
&#123;
    public static void main(String[] args)
    &#123;
        Proxy proxy=new Proxy();
        proxy.Request();
    &#125;
&#125;
//抽象主题
interface Subject
&#123;
    void Request();
&#125;
//真实主题
class RealSubject implements Subject
&#123;
    public void Request()
    &#123;
        System.out.println(&quot;访问真实主题方法...&quot;);
    &#125;
&#125;
//代理
class Proxy implements Subject
&#123;
    private RealSubject realSubject;
    public void Request()
    &#123;
        if (realSubject==null)
        &#123;
            realSubject=new RealSubject();
        &#125;
        preRequest();
        realSubject.Request();
        postRequest();
    &#125;
    public void preRequest()
    &#123;
        System.out.println(&quot;访问真实主题之前的预处理。&quot;);
    &#125;
    public void postRequest()
    &#123;
        System.out.println(&quot;访问真实主题之后的后续处理。&quot;);
    &#125;
&#125;

&gt; 访问真实主题之前的预处理。
&gt; 访问真实主题方法...
&gt; 访问真实主题之后的后续处理。</code></pre>
<h4 id="代理模式的应用实例"><a href="#代理模式的应用实例" class="headerlink" title="代理模式的应用实例"></a>代理模式的应用实例</h4><p> <strong>韶关“天街e角”公司是一家婺源特产公司的代理公司，用代理模式实现</strong> </p>
<p>本实例中的“婺源特产公司”经营许多婺源特产，它是真实主题，提供了显示特产的 display() 方法，可以用窗体程序实现。而韶关“天街e角”公司是婺源特产公司特产的代理，通过调用婺源特产公司的 display() 方法显示代理产品，当然它可以增加一些额外的处理，如包裝或加价等。客户可通过“天街e角”代理公司间接访问“婺源特产公司”的产品 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E9%9F%B6%E5%85%B3%E2%80%9C%E5%A4%A9%E8%A1%97e%E8%A7%92%E2%80%9D%E5%85%AC%E5%8F%B8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package proxy;
import java.awt.*;
import javax.swing.*;
public class WySpecialtyProxy
&#123;
    public static void main(String[] args)
    &#123;
        SgProxy proxy=new SgProxy();
        proxy.display();
    &#125;
&#125;
//抽象主题：特产
interface Specialty
&#123;
    void display();
&#125;
//真实主题：婺源特产
class WySpecialty extends JFrame implements Specialty
&#123;
    private static final long serialVersionUID=1L;
    public WySpecialty()
    &#123;
        super(&quot;韶关代理婺源特产测试&quot;);
        this.setLayout(new GridLayout(1,1));
        JLabel l1=new JLabel(new ImageIcon(&quot;src/proxy/WuyuanSpecialty.jpg&quot;));
        this.add(l1);   
        this.pack();       
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);      
    &#125;
    public void display()
    &#123;
        this.setVisible(true);
    &#125;
&#125;
//代理：韶关代理
class SgProxy implements Specialty
&#123;
    private WySpecialty realSubject=new WySpecialty();
    public void display()
    &#123;
        preRequest();
        realSubject.display();
        postRequest();
    &#125;
    public void preRequest()
    &#123;
          System.out.println(&quot;韶关代理婺源特产开始。&quot;);
    &#125;
    public void postRequest()
    &#123;
          System.out.println(&quot;韶关代理婺源特产结束。&quot;);
    &#125;
&#125;</code></pre>
<h4 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h4><ul>
<li>远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</li>
<li>虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li>
<li>安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。</li>
<li>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</li>
<li>延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate中就存在属性的延迟加载和关联表的延时加载。</li>
</ul>
<h4 id="代理模式的扩展"><a href="#代理模式的扩展" class="headerlink" title="代理模式的扩展"></a>代理模式的扩展</h4><p>代理类中包含了对真实主题的引用，这种方式存在两个缺点。</p>
<ol>
<li>真实主题与代理主题一一对应，增加真实主题也要增加代理。</li>
<li>设计代理以前真实主题必须事先存在，不太灵活。采用动态代理模式可以解决以上问题，如 SpringAOP。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h3 id="2-适配器（Adapter）模式"><a href="#2-适配器（Adapter）模式" class="headerlink" title="2.适配器（Adapter）模式"></a>2.适配器（Adapter）模式</h3><p>在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。 </p>
<p>在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。 </p>
<h4 id="模式的定义与特点-3"><a href="#模式的定义与特点-3" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h4><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。 </p>
<p>该模式的主要优点如下。</p>
<ul>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
</ul>
<p>其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。 </p>
<h4 id="模式的结构与实现-3"><a href="#模式的结构与实现-3" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><p>类适配器模式可采用多重继承方式实现，如 C++可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。 </p>
<p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。 </p>
<h5 id="1-模式的结构-4"><a href="#1-模式的结构-4" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li><p>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</p>
</li>
<li><p>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</p>
</li>
<li><p>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</p>
<p><strong>类适配器模式的结构图</strong> </p>
</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<p> <strong>对象适配器模式的结构图</strong> </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-4"><a href="#2-模式的实现-4" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><p>(1) 类适配器模式 </p>
<pre><code class="java">package adapter;
//目标接口
interface Target
&#123;
    public void request();
&#125;
//适配者接口
class Adaptee
&#123;
    public void specificRequest()
    &#123;       
        System.out.println(&quot;适配者中的业务代码被调用！&quot;);
    &#125;
&#125;
//类适配器类
class ClassAdapter extends Adaptee implements Target
&#123;
    public void request()
    &#123;
        specificRequest();
    &#125;
&#125;
//客户端代码
public class ClassAdapterTest
&#123;
    public static void main(String[] args)
    &#123;
        System.out.println(&quot;类适配器模式测试：&quot;);
        Target target = new ClassAdapter();
        target.request();
    &#125;
&#125;

&gt; 类适配器模式测试：
&gt; 适配者中的业务代码被调用！</code></pre>
<p>(2)对象适配器模式 </p>
<pre><code class="java">package adapter;
//对象适配器类
class ObjectAdapter implements Target
&#123;
    private Adaptee adaptee;
    public ObjectAdapter(Adaptee adaptee)
    &#123;
        this.adaptee=adaptee;
    &#125;
    public void request()
    &#123;
        adaptee.specificRequest();
    &#125;
&#125;
//客户端代码
public class ObjectAdapterTest
&#123;
    public static void main(String[] args)
    &#123;
        System.out.println(&quot;对象适配器模式测试：&quot;);
        Adaptee adaptee = new Adaptee();
        Target target = new ObjectAdapter(adaptee);
        target.request();
    &#125;
&#125;

&gt; 对象适配器模式测试：
&gt; 适配者中的业务代码被调用！</code></pre>
<blockquote>
<p> 对象适配器模式中的“目标接口”和“适配者类”的代码同类适配器模式一样，只要修改适配器类和客户端的代码即可。 </p>
</blockquote>
<h4 id="模式的应用实例-2"><a href="#模式的应用实例-2" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h4><p><strong>用适配器模式（Adapter）模拟新能源汽车的发动机</strong> </p>
<p>新能源汽车的发动机有电能发动机（Electric Motor）和光能发动机（Optical Motor）等，各种发动机的驱动方法不同，例如，电能发动机的驱动方法 electricDrive() 是用电能驱动，而光能发动机的驱动方法 opticalDrive() 是用光能驱动，它们是适配器模式中被访问的适配者。 </p>
<p>客户端希望用统一的发动机驱动方法 drive() 访问这两种发动机，所以必须定义一个统一的目标接口 Motor，然后再定义电能适配器（Electric Adapter）和光能适配器（Optical Adapter）去适配这两种发动机。 </p>
<p>我们把客户端想访问的新能源发动机的适配器的名称放在 XML 配置文件中，客户端可以通过对象生成器类 ReadXML 去读取。这样，客户端就可以通过 Motor 接口随便使用任意一种新能源发动机去驱动汽车。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8F%91%E5%8A%A8%E6%9C%BA%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package adapter;
//目标：发动机
interface Motor
&#123;
    public void drive();
&#125;
//适配者1：电能发动机
class ElectricMotor
&#123;
    public void electricDrive()
    &#123;
        System.out.println(&quot;电能发动机驱动汽车！&quot;);
    &#125;
&#125;
//适配者2：光能发动机
class OpticalMotor
&#123;
    public void opticalDrive()
    &#123;
        System.out.println(&quot;光能发动机驱动汽车！&quot;);
    &#125;
&#125;
//电能适配器
class ElectricAdapter implements Motor
&#123;
    private ElectricMotor emotor;
    public ElectricAdapter()
    &#123;
        emotor=new ElectricMotor();
    &#125;
    public void drive()
    &#123;
        emotor.electricDrive();
    &#125;
&#125;
//光能适配器
class OpticalAdapter implements Motor
&#123;
    private OpticalMotor omotor;
    public OpticalAdapter()
    &#123;
        omotor=new OpticalMotor();
    &#125;
    public void drive()
    &#123;
        omotor.opticalDrive();
    &#125;
&#125;
//客户端代码
public class MotorAdapterTest
&#123;
    public static void main(String[] args)
    &#123;
        System.out.println(&quot;适配器模式测试：&quot;);
        Motor motor=(Motor)ReadXML.getObject();
        motor.drive();
    &#125;
&#125;</code></pre>
<pre><code class="java">package adapter;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import java.io.*;
class ReadXML
&#123;
    public static Object getObject()
    &#123;
        try
        &#123;
            DocumentBuilderFactory dFactory=DocumentBuilderFactory.newInstance();
            DocumentBuilder builder=dFactory.newDocumentBuilder();
            Document doc;                           
            doc=builder.parse(new File(&quot;src/adapter/config.xml&quot;));
            NodeList nl=doc.getElementsByTagName(&quot;className&quot;);
            Node classNode=nl.item(0).getFirstChild();
            String cName=&quot;adapter.&quot;+classNode.getNodeValue();
            Class&lt;?&gt; c=Class.forName(cName);
              Object obj=c.newInstance();
            return obj;
         &#125;  
         catch(Exception e)
         &#123;
                   e.printStackTrace();
                   return null;
         &#125;
    &#125;
&#125;</code></pre>
<p>程序的运行结果如下：</p>
<pre><code>适配器模式测试：
电能发动机驱动汽车！</code></pre>
<p>注意：如果将配置文件中的 ElectricAdapter 改为 OpticalAdapter，则运行结果如下：</p>
<pre><code>适配器模式测试：
光能发动机驱动汽车！</code></pre>
<h4 id="模式的应用场景-2"><a href="#模式的应用场景-2" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h4><ul>
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li>
<li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li>
</ul>
<h4 id="模式的扩展-2"><a href="#模式的扩展-2" class="headerlink" title="模式的扩展"></a>模式的扩展</h4><p>适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8F%8C%E5%90%91%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package adapter;
//目标接口
interface TwoWayTarget
&#123;
    public void request();
&#125;
//适配者接口
interface TwoWayAdaptee
&#123;
    public void specificRequest();
&#125;
//目标实现
class TargetRealize implements TwoWayTarget
&#123;
    public void request()
    &#123;       
        System.out.println(&quot;目标代码被调用！&quot;);
    &#125;
&#125;
//适配者实现
class AdapteeRealize implements TwoWayAdaptee
&#123;
    public void specificRequest()
    &#123;       
        System.out.println(&quot;适配者代码被调用！&quot;);
    &#125;
&#125;
//双向适配器
class TwoWayAdapter  implements TwoWayTarget,TwoWayAdaptee
&#123;
    private TwoWayTarget target;
    private TwoWayAdaptee adaptee;
    public TwoWayAdapter(TwoWayTarget target)
    &#123;
        this.target=target;
    &#125;
    public TwoWayAdapter(TwoWayAdaptee adaptee)
    &#123;
        this.adaptee=adaptee;
    &#125;
    public void request()
    &#123;
        adaptee.specificRequest();
    &#125;
    public void specificRequest()
    &#123;       
        target.request();
    &#125;
&#125;
//客户端代码
public class TwoWayAdapterTest
&#123;
    public static void main(String[] args)
    &#123;
        System.out.println(&quot;目标通过双向适配器访问适配者：&quot;);
        TwoWayAdaptee adaptee=new AdapteeRealize();
        TwoWayTarget target=new TwoWayAdapter(adaptee);
        target.request();
        System.out.println(&quot;-------------------&quot;);
        System.out.println(&quot;适配者通过双向适配器访问目标：&quot;);
        target=new TargetRealize();
        adaptee=new TwoWayAdapter(target);
        adaptee.specificRequest();
    &#125;
&#125;</code></pre>
<pre><code>目标通过双向适配器访问适配者：
适配者代码被调用！
-------------------
适配者通过双向适配器访问目标：
目标代码被调用！</code></pre>
<h3 id="3-桥接（Bridge）模式"><a href="#3-桥接（Bridge）模式" class="headerlink" title="3.桥接（Bridge）模式"></a>3.桥接（Bridge）模式</h3><p>在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。 当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。 </p>
<h4 id="桥接模式的定义与特点"><a href="#桥接模式的定义与特点" class="headerlink" title="桥接模式的定义与特点"></a>桥接模式的定义与特点</h4><p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 </p>
<p>桥接（Bridge）模式的优点是：</p>
<ul>
<li>由于抽象与实现分离，所以扩展能力强；</li>
<li>其实现细节对客户透明。</li>
</ul>
<p>缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。 </p>
<h4 id="桥接模式的结构与实现"><a href="#桥接模式的结构与实现" class="headerlink" title="桥接模式的结构与实现"></a>桥接模式的结构与实现</h4><p>可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p>
<h5 id="1-模式的结构-5"><a href="#1-模式的结构-5" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined  Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-5"><a href="#2-模式的实现-5" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package bridge;
public class BridgeTest
&#123;
    public static void main(String[] args)
    &#123;
        Implementor imple=new ConcreteImplementorA();
        Abstraction abs=new RefinedAbstraction(imple);
        abs.Operation();
    &#125;
&#125;
//实现化角色
interface Implementor
&#123;
    public void OperationImpl();
&#125;
//具体实现化角色
class ConcreteImplementorA implements Implementor
&#123;
    public void OperationImpl()
    &#123;
        System.out.println(&quot;具体实现化(Concrete Implementor)角色被访问&quot; );
    &#125;
&#125;
//抽象化角色
abstract class Abstraction
&#123;
   protected Implementor imple;
   protected Abstraction(Implementor imple)
   &#123;
       this.imple=imple;
   &#125;
   public abstract void Operation();   
&#125;
//扩展抽象化角色
class RefinedAbstraction extends Abstraction
&#123;
   protected RefinedAbstraction(Implementor imple)
   &#123;
       super(imple);
   &#125;
   public void Operation()
   &#123;
       System.out.println(&quot;扩展抽象化(Refined Abstraction)角色被访问&quot; );
       imple.OperationImpl();
   &#125;
&#125;

&gt; 扩展抽象化(Refined Abstraction)角色被访问
&gt; 具体实现化(Concrete Implementor)角色被访问</code></pre>
<h4 id="桥接模式的应用实例"><a href="#桥接模式的应用实例" class="headerlink" title="桥接模式的应用实例"></a>桥接模式的应用实例</h4><p><strong>用桥接（Bridge）模式模拟女士皮包的选购</strong> </p>
<p>女士皮包有很多种，可以按用途分、按皮质分、按品牌分、按颜色分、按大小分等，存在多个维度的变化，所以采用桥接模式来实现女士皮包的选购比较合适。</p>
<p>本实例按用途分可选钱包（Wallet）和挎包（HandBag），按颜色分可选黄色（Yellow）和红色（Red）。可以按两个维度定义为颜色类和包类。 </p>
<p>颜色类（Color）是一个维度，定义为实现化角色，它有两个具体实现化角色：黄色和红色，通过 getColor() 方法可以选择颜色；包类（Bag）是另一个维度，定义为抽象化角色，它有两个扩展抽象化角色：挎包和钱包，它包含了颜色类对象，通过 getName() 方法可以选择相关颜色的挎包和钱包。 </p>
<p>客户类通过 ReadXML 类从 XML 配置文件中获取包信息，并把选到的产品通过窗体显示出现 。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A5%B3%E5%A3%AB%E7%9A%AE%E5%8C%85%E9%80%89%E8%B4%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package bridge;
import java.awt.*;
import javax.swing.*;
public class BagManage
&#123;
    public static void main(String[] args)
    &#123;
        Color color;
        Bag bag;
        color=(Color)ReadXML.getObject(&quot;color&quot;);
        bag=(Bag)ReadXML.getObject(&quot;bag&quot;);
        bag.setColor(color);
        String name=bag.getName();
        show(name);
    &#125;
    public static void show(String name)
    &#123;
        JFrame jf=new JFrame(&quot;桥接模式测试&quot;);
        Container contentPane=jf.getContentPane();
        JPanel p=new JPanel();   
        JLabel l=new JLabel(new ImageIcon(&quot;src/bridge/&quot;+name+&quot;.jpg&quot;));
        p.setLayout(new GridLayout(1,1));
        p.setBorder(BorderFactory.createTitledBorder(&quot;女士皮包&quot;));
        p.add(l);
        contentPane.add(p, BorderLayout.CENTER);
        jf.pack();  
        jf.setVisible(true);
        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;
&#125;
//实现化角色：颜色
interface Color
&#123;
    String getColor();
&#125;
//具体实现化角色：黄色
class Yellow implements Color
&#123;
    public String getColor()
    &#123;
        return &quot;yellow&quot;;
    &#125;
&#125;
//具体实现化角色：红色
class Red implements Color
&#123;
    public String getColor()
    &#123;
        return &quot;red&quot;;
    &#125;
&#125;
//抽象化角色：包
abstract class Bag
&#123;
    protected Color color;
    public void setColor(Color color)
    &#123;
        this.color=color;
    &#125;   
    public abstract String getName();
&#125;
//扩展抽象化角色：挎包
class HandBag extends Bag
&#123;
    public String getName()
    &#123;
        return color.getColor()+&quot;HandBag&quot;;
    &#125;   
&#125;
//扩展抽象化角色：钱包
class Wallet extends Bag
&#123;
    public String getName()
    &#123;
        return color.getColor()+&quot;Wallet&quot;;
    &#125;   
&#125;</code></pre>
<pre><code class="java">package bridge;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import java.io.*;
class ReadXML
&#123;
    public static Object getObject(String args)
    &#123;
        try
        &#123;
            DocumentBuilderFactory dFactory=DocumentBuilderFactory.newInstance();
            DocumentBuilder builder=dFactory.newDocumentBuilder();
            Document doc;                           
            doc=builder.parse(new File(&quot;src/bridge/config.xml&quot;));
            NodeList nl=doc.getElementsByTagName(&quot;className&quot;);
            Node classNode=null;
            if(args.equals(&quot;color&quot;))
            &#123;
                classNode=nl.item(0).getFirstChild();
            &#125;
            else if(args.equals(&quot;bag&quot;))
            &#123;
                classNode=nl.item(1).getFirstChild();
            &#125;          
            String cName=&quot;bridge.&quot;+classNode.getNodeValue();
            Class&lt;?&gt; c=Class.forName(cName);
              Object obj=c.newInstance();
            return obj;
        &#125;  
        catch(Exception e)
        &#123;
               e.printStackTrace();
               return null;
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="桥接模式的应用场景"><a href="#桥接模式的应用场景" class="headerlink" title="桥接模式的应用场景"></a>桥接模式的应用场景</h4><ol>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</li>
</ol>
<h4 id="桥接模式模式的扩展"><a href="#桥接模式模式的扩展" class="headerlink" title="桥接模式模式的扩展"></a>桥接模式模式的扩展</h4><p>在软件开发中，有时桥接（Bridge）模式可与适配器模式联合使用。当桥接（Bridge）模式的实现化角色的接口与现有类的接口不一致时，可以在二者中间定义一个适配器将二者连接起来。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%81%94%E7%94%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h3 id="4-装饰（Decorator）模式"><a href="#4-装饰（Decorator）模式" class="headerlink" title="4.装饰（Decorator）模式"></a>4.装饰（Decorator）模式</h3><p>在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等。在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰模式来实现。 </p>
<h4 id="装饰模式的定义与特点"><a href="#装饰模式的定义与特点" class="headerlink" title="装饰模式的定义与特点"></a>装饰模式的定义与特点</h4><p>装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<ul>
<li>采用装饰模式扩展对象的功能比采用继承方式更加灵活。</li>
<li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</li>
</ul>
<p>其主要缺点是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p>
<h4 id="装饰模式的结构与实现"><a href="#装饰模式的结构与实现" class="headerlink" title="装饰模式的结构与实现"></a>装饰模式的结构与实现</h4><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。 </p>
<h5 id="1-模式的结构-6"><a href="#1-模式的结构-6" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（Concrete  Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-6"><a href="#2-模式的实现-6" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package decorator;
public class DecoratorPattern
&#123;
    public static void main(String[] args)
    &#123;
        Component p=new ConcreteComponent();
        p.operation();
        System.out.println(&quot;---------------------------------&quot;);
        Component d=new ConcreteDecorator(p);
        d.operation();
    &#125;
&#125;
//抽象构件角色
interface  Component
&#123;
    public void operation();
&#125;
//具体构件角色
class ConcreteComponent implements Component
&#123;
    public ConcreteComponent()
    &#123;
        System.out.println(&quot;创建具体构件角色&quot;);       
    &#125;   
    public void operation()
    &#123;
        System.out.println(&quot;调用具体构件角色的方法operation()&quot;);           
    &#125;
&#125;
//抽象装饰角色
class Decorator implements Component
&#123;
    private Component component;   
    public Decorator(Component component)
    &#123;
        this.component=component;
    &#125;   
    public void operation()
    &#123;
        component.operation();
    &#125;
&#125;
//具体装饰角色
class ConcreteDecorator extends Decorator
&#123;
    public ConcreteDecorator(Component component)
    &#123;
        super(component);
    &#125;   
    public void operation()
    &#123;
        super.operation();
        addedFunction();
    &#125;
    public void addedFunction()
    &#123;
        System.out.println(&quot;为具体构件角色增加额外的功能addedFunction()&quot;);           
    &#125;
&#125;

创建具体构件角色
调用具体构件角色的方法operation()
---------------------------------
调用具体构件角色的方法operation()
为具体构件角色增加额外的功能addedFunction()</code></pre>
<h4 id="装饰模式的应用实例"><a href="#装饰模式的应用实例" class="headerlink" title="装饰模式的应用实例"></a>装饰模式的应用实例</h4><p><strong>用装饰模式实现游戏角色“莫莉卡·安斯兰”的变身</strong> </p>
<p>在《恶魔战士》中，游戏角色“莫莉卡·安斯兰”的原身是一个可爱少女，但当她变身时，会变成头顶及背部延伸出蝙蝠状飞翼的女妖，当然她还可以变为穿着漂亮外衣的少女。这些都可用装饰模式来实现，在本实例中的“莫莉卡”原身有 setImage(String t) 方法决定其显示方式，而其 变身“蝙蝠状女妖”和“着装少女”可以用 setChanger() 方法来改变其外观，原身与变身后的效果用 display() 方法来显示 。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E2%80%9C%E8%8E%AB%E8%8E%89%E5%8D%A1%C2%B7%E5%AE%89%E6%96%AF%E5%85%B0%E2%80%9D%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package decorator;
import java.awt.*;
import javax.swing.*;
public class MorriganAensland
&#123;
    public static void main(String[] args)
    &#123;
        Morrigan m0=new original();
        m0.display();
        Morrigan m1=new Succubus(m0);
        m1.display();
        Morrigan m2=new Girl(m0);
        m2.display();
    &#125;
&#125;
//抽象构件角色：莫莉卡
interface  Morrigan
&#123;
    public void display();
&#125;
//具体构件角色：原身
class original extends JFrame implements Morrigan
&#123;
    private static final long serialVersionUID = 1L;
    private String t=&quot;Morrigan0.jpg&quot;;
    public original()
    &#123;
        super(&quot;《恶魔战士》中的莫莉卡·安斯兰&quot;);                
    &#125;
    public void setImage(String t)
    &#123;
        this.t=t;           
    &#125;
    public void display()
    &#123;   
        this.setLayout(new FlowLayout());
        JLabel l1=new JLabel(new ImageIcon(&quot;src/decorator/&quot;+t));
        this.add(l1);   
        this.pack();       
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  
        this.setVisible(true);
    &#125;
&#125;
//抽象装饰角色：变形
class Changer implements Morrigan
&#123;
    Morrigan m;   
    public Changer(Morrigan m)
    &#123;
        this.m=m;
    &#125;   
    public void display()
    &#123;
        m.display();
    &#125;
&#125;
//具体装饰角色：女妖
class Succubus extends Changer
&#123;
    public Succubus(Morrigan m)
    &#123;
        super(m);
    &#125;   
    public void display()
    &#123;
        setChanger();
        super.display();   
    &#125;
    public void setChanger()
    &#123;
        ((original) super.m).setImage(&quot;Morrigan1.jpg&quot;);           
    &#125;
&#125;
//具体装饰角色：少女
class Girl extends Changer
&#123;
    public Girl(Morrigan m)
    &#123;
        super(m);
    &#125;   
    public void display()
    &#123;
        setChanger();
        super.display();   
    &#125;
    public void setChanger()
    &#123;
        ((original) super.m).setImage(&quot;Morrigan2.jpg&quot;);           
    &#125;
&#125;</code></pre>
<h4 id="装饰模式的应用场景"><a href="#装饰模式的应用场景" class="headerlink" title="装饰模式的应用场景"></a>装饰模式的应用场景</h4><ul>
<li>当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。</li>
<li>当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。</li>
<li>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</li>
</ul>
<p>装饰模式在 Java 语言中的最著名的应用莫过于 Java I/O 标准库的设计了。例如，InputStream 的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。</p>
<p>下面代码是为 FileReader 增加缓冲区而采用的装饰类 BufferedReader 的例子： </p>
<pre><code class="java">BufferedReader in=new BufferedReader(new FileReader(&quot;filename.txtn));
String s=in.readLine();</code></pre>
<h4 id="装饰模式的扩展"><a href="#装饰模式的扩展" class="headerlink" title="装饰模式的扩展"></a>装饰模式的扩展</h4><p>装饰模式所包含的 4 个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，如以下两种情况。</p>
<p>(1) 如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件 :</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%85%B7%E4%BD%93%E6%9E%84%E4%BB%B6%E7%9A%84%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.gif"></p>
<p> (2) 如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并 :</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%85%B7%E4%BD%93%E8%A3%85%E9%A5%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.gif"></p>
<h3 id="5-外观（Facade）模式"><a href="#5-外观（Facade）模式" class="headerlink" title="5.外观（Facade）模式"></a>5.外观（Facade）模式</h3><p>在现实生活中，常常存在办事较复杂的例子，如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。</p>
<p>软件设计也是这样，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了“开闭原则”，也违背了“迪米特法则”，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8A%9E%E7%90%86%E6%88%BF%E4%BA%A7%E8%AF%81%E8%BF%87%E6%88%B7%E7%9A%84%E7%9B%B8%E5%85%B3%E9%83%A8%E9%97%A8.gif"></p>
<h4 id="外观模式的定义与特点"><a href="#外观模式的定义与特点" class="headerlink" title="外观模式的定义与特点"></a>外观模式的定义与特点</h4><p>外观（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。 </p>
<p>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。</p>
<ol>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ol>
<p>外观（Facade）模式的主要缺点如下。</p>
<ol>
<li>不能很好地限制客户使用子系统类。</li>
<li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ol>
<h4 id="外观模式的结构与实现"><a href="#外观模式的结构与实现" class="headerlink" title="外观模式的结构与实现"></a>外观模式的结构与实现</h4><p>外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。现在来分析其基本结构和实现方法。 </p>
<h5 id="1-模式的结构-7"><a href="#1-模式的结构-7" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>
<li>客户（Client）角色：通过一个外观角色访问各个子系统的功能。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A4%96%E8%A7%82%EF%BC%88Facade%EF%BC%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-7"><a href="#2-模式的实现-7" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package facade;
public class FacadePattern
&#123;
    public static void main(String[] args)
    &#123;
        Facade f=new Facade();
        f.method();
    &#125;
&#125;
//外观角色
class Facade
&#123;
    private SubSystem01 obj1=new SubSystem01();
    private SubSystem02 obj2=new SubSystem02();
    private SubSystem03 obj3=new SubSystem03();
    public void method()
    &#123;
        obj1.method1();
        obj2.method2();
        obj3.method3();
    &#125;
&#125;
//子系统角色
class SubSystem01
&#123;
    public  void method1()
    &#123;
        System.out.println(&quot;子系统01的method1()被调用！&quot;);
    &#125;   
&#125;
//子系统角色
class SubSystem02
&#123;
    public  void method2()
    &#123;
        System.out.println(&quot;子系统02的method2()被调用！&quot;);
    &#125;   
&#125;
//子系统角色
class SubSystem03
&#123;
    public  void method3()
    &#123;
        System.out.println(&quot;子系统03的method3()被调用！&quot;);
    &#125;   
&#125;

子系统01的method1()被调用！
子系统02的method2()被调用！
子系统03的method3()被调用！</code></pre>
<h4 id="外观模式的应用实例"><a href="#外观模式的应用实例" class="headerlink" title="外观模式的应用实例"></a>外观模式的应用实例</h4><p><strong>用“外观模式”设计一个婺源特产的选购界面</strong> </p>
<p>本实例的外观角色 WySpecialty 是 JPanel 的子类，它拥有 8 个子系统角色 Specialty1~Specialty8，它们是图标类（ImageIcon）的子类对象，用来保存该婺源特产的图标。 </p>
<p>外观类（WySpecialty）用 JTree 组件来管理婺源特产的名称，并定义一个事件处理方法 valueClianged(TreeSelectionEvent e)，当用户从树中选择特产时，该特产的图标对象保存在标签（JLabd）对象中。</p>
<p>客户窗体对象用分割面板来实现，左边放外观角色的目录树，右边放显示所选特产图像的标签。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A9%BA%E6%BA%90%E7%89%B9%E4%BA%A7%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package facade;
import java.awt.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.DefaultMutableTreeNode;
public class WySpecialtyFacade
&#123;
    public static void main(String[] args)
    &#123;
        JFrame f=new JFrame (&quot;外观模式: 婺源特产选择测试&quot;);
        Container cp=f.getContentPane();       
        WySpecialty wys=new WySpecialty();       
        JScrollPane treeView=new JScrollPane(wys.tree);
        JScrollPane scrollpane=new JScrollPane(wys.label);       
        JSplitPane splitpane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,true,treeView,scrollpane); //分割面版
        splitpane.setDividerLocation(230);     //设置splitpane的分隔线位置
        splitpane.setOneTouchExpandable(true); //设置splitpane可以展开或收起                       
        cp.add(splitpane);
        f.setSize(650,350);
        f.setVisible(true);   
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;
&#125;
class WySpecialty extends JPanel implements TreeSelectionListener
&#123;
    private static final long serialVersionUID=1L;
    final JTree tree;
    JLabel label;
    private Specialty1 s1=new Specialty1();
    private Specialty2 s2=new Specialty2();
    private Specialty3 s3=new Specialty3();
    private Specialty4 s4=new Specialty4();
    private Specialty5 s5=new Specialty5();
    private Specialty6 s6=new Specialty6();
    private Specialty7 s7=new Specialty7();
    private Specialty8 s8=new Specialty8();
    WySpecialty()&#123;       
        DefaultMutableTreeNode top=new DefaultMutableTreeNode(&quot;婺源特产&quot;);
        DefaultMutableTreeNode node1=null,node2=null,tempNode=null;       
        node1=new DefaultMutableTreeNode(&quot;婺源四大特产（红、绿、黑、白）&quot;);
        tempNode=new DefaultMutableTreeNode(&quot;婺源荷包红鲤鱼&quot;);
        node1.add(tempNode);
        tempNode=new DefaultMutableTreeNode(&quot;婺源绿茶&quot;);
        node1.add(tempNode);
        tempNode=new DefaultMutableTreeNode(&quot;婺源龙尾砚&quot;);
        node1.add(tempNode);
        tempNode=new DefaultMutableTreeNode(&quot;婺源江湾雪梨&quot;);
        node1.add(tempNode);
        top.add(node1);           
        node2=new DefaultMutableTreeNode(&quot;婺源其它土特产&quot;);
        tempNode=new DefaultMutableTreeNode(&quot;婺源酒糟鱼&quot;);
        node2.add(tempNode);
        tempNode=new DefaultMutableTreeNode(&quot;婺源糟米子糕&quot;);
        node2.add(tempNode);
        tempNode=new DefaultMutableTreeNode(&quot;婺源清明果&quot;);
        node2.add(tempNode);
        tempNode=new DefaultMutableTreeNode(&quot;婺源油煎灯&quot;);
        node2.add(tempNode);
        top.add(node2);           
        tree=new JTree(top);
        tree.addTreeSelectionListener(this);
        label=new JLabel();
    &#125;   
    public void valueChanged(TreeSelectionEvent e)
    &#123;
        if(e.getSource()==tree)
        &#123;
            DefaultMutableTreeNode node=(DefaultMutableTreeNode) tree.getLastSelectedPathComponent();
            if(node==null) return;
            if(node.isLeaf())
            &#123;
                Object object=node.getUserObject();
                String sele=object.toString();
                label.setText(sele);
                label.setHorizontalTextPosition(JLabel.CENTER);
                label.setVerticalTextPosition(JLabel.BOTTOM);
                sele=sele.substring(2,4);
                if(sele.equalsIgnoreCase(&quot;荷包&quot;)) label.setIcon(s1);
                else if(sele.equalsIgnoreCase(&quot;绿茶&quot;)) label.setIcon(s2);
                else if(sele.equalsIgnoreCase(&quot;龙尾&quot;)) label.setIcon(s3);
                else if(sele.equalsIgnoreCase(&quot;江湾&quot;)) label.setIcon(s4);
                else if(sele.equalsIgnoreCase(&quot;酒糟&quot;)) label.setIcon(s5);
                else if(sele.equalsIgnoreCase(&quot;糟米&quot;)) label.setIcon(s6);
                else if(sele.equalsIgnoreCase(&quot;清明&quot;)) label.setIcon(s7);
                else if(sele.equalsIgnoreCase(&quot;油煎&quot;)) label.setIcon(s8);
                label.setHorizontalAlignment(JLabel.CENTER);
            &#125;
        &#125;               
    &#125;
&#125;
class Specialty1 extends ImageIcon
&#123;
    private static final long serialVersionUID=1L;
    Specialty1()
    &#123;
        super(&quot;src/facade/WyImage/Specialty11.jpg&quot;);
    &#125;
&#125;
class Specialty2 extends ImageIcon
&#123;
    private static final long serialVersionUID=1L;
    Specialty2()
    &#123;
        super(&quot;src/facade/WyImage/Specialty12.jpg&quot;);
    &#125;
&#125;
class Specialty3 extends ImageIcon
&#123;
    private static final long serialVersionUID=1L;
    Specialty3()
    &#123;
        super(&quot;src/facade/WyImage/Specialty13.jpg&quot;);
    &#125;
&#125;
class Specialty4 extends ImageIcon
&#123;
    private static final long serialVersionUID=1L;
    Specialty4()
    &#123;
        super(&quot;src/facade/WyImage/Specialty14.jpg&quot;);
    &#125;
&#125;
class Specialty5 extends ImageIcon
&#123;
    private static final long serialVersionUID=1L;
    Specialty5()
    &#123;
        super(&quot;src/facade/WyImage/Specialty21.jpg&quot;);
    &#125;
&#125;
class Specialty6 extends ImageIcon
&#123;
    private static final long serialVersionUID=1L;
    Specialty6()
    &#123;
        super(&quot;src/facade/WyImage/Specialty22.jpg&quot;);
    &#125;
&#125;
class Specialty7 extends ImageIcon
&#123;
    private static final long serialVersionUID=1L;
    Specialty7()
    &#123;
        super(&quot;src/facade/WyImage/Specialty23.jpg&quot;);
    &#125;
&#125;
class Specialty8 extends ImageIcon
&#123;
    private static final long serialVersionUID=1L;
    Specialty8()
    &#123;
        super(&quot;src/facade/WyImage/Specialty24.jpg&quot;);
    &#125;
&#125;</code></pre>
<h4 id="外观模式的应用场景"><a href="#外观模式的应用场景" class="headerlink" title="外观模式的应用场景"></a>外观模式的应用场景</h4><ol>
<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>
<li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li>
<li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li>
</ol>
<h4 id="外观模式的扩展"><a href="#外观模式的扩展" class="headerlink" title="外观模式的扩展"></a>外观模式的扩展</h4><p>在外观模式中，当增加或移除子系统时需要修改外观类，这违背了“开闭原则”。如果引入抽象外观类，则在一定程度上解决了该问题。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%BC%95%E5%85%A5%E6%8A%BD%E8%B1%A1%E5%A4%96%E8%A7%82%E7%B1%BB%E7%9A%84%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h3 id="6-享元（Flyweight）模式"><a href="#6-享元（Flyweight）模式" class="headerlink" title="6.享元（Flyweight）模式"></a>6.享元（Flyweight）模式</h3><p>在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。例如，围棋和五子棋中的黑白棋子，图像中的坐标点或颜色，局域网中的路由器、交换机和集线器，教室里的桌子和凳子等。这些对象有很多相似的地方，如果能把它们相同的部分提取出来共享，则能节省大量的系统资源，这就是享元模式的产生背景。 </p>
<h4 id="享元模式的定义与特点"><a href="#享元模式的定义与特点" class="headerlink" title="享元模式的定义与特点"></a>享元模式的定义与特点</h4><p>享元（Flyweight）模式的定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。 </p>
<p>享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。 </p>
<p>其主要缺点是：</p>
<ol>
<li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li>
<li>读取享元模式的外部状态会使得运行时间稍微变长。</li>
</ol>
<h4 id="享元模式的结构与实现"><a href="#享元模式的结构与实现" class="headerlink" title="享元模式的结构与实现"></a>享元模式的结构与实现</h4><p>享元模式中存在以下两种状态：</p>
<ol>
<li>内部状态，即不会随着环境的改变而改变的可共享部分；</li>
<li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。下面来分析其基本结构和实现方法。</li>
</ol>
<h5 id="1-模式的结构-8"><a href="#1-模式的结构-8" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。</li>
<li>具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。</li>
<li>非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。</li>
<li>享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<blockquote>
<p>图中的 UnsharedConcreteFlyweight 是与享元角色，里面包含了非共享的外部状态信息 info；而 Flyweight 是抽象享元角色，里面包含了享元方法 operation(UnsharedConcreteFlyweight state)，非享元的外部状态以参数的形式通过该方法传入；ConcreteFlyweight 是具体享元角色，包含了关键字 key，它实现了抽象享元接口；FlyweightFactory 是享元工厂角色，它逝关键字 key 来管理具体享元；客户角色通过享元工厂获取具体享元，并访问具体享元的相关方法。 </p>
</blockquote>
<h5 id="2-模式的实现-8"><a href="#2-模式的实现-8" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package flyweight;
import java.util.HashMap;
public class FlyweightPattern
&#123;
    public static void main(String[] args)
    &#123;
        FlyweightFactory factory=new FlyweightFactory();
        Flyweight f01=factory.getFlyweight(&quot;a&quot;);
        Flyweight f02=factory.getFlyweight(&quot;a&quot;);
        Flyweight f03=factory.getFlyweight(&quot;a&quot;);
        Flyweight f11=factory.getFlyweight(&quot;b&quot;);
        Flyweight f12=factory.getFlyweight(&quot;b&quot;);       
        f01.operation(new UnsharedConcreteFlyweight(&quot;第1次调用a。&quot;));       
        f02.operation(new UnsharedConcreteFlyweight(&quot;第2次调用a。&quot;));       
        f03.operation(new UnsharedConcreteFlyweight(&quot;第3次调用a。&quot;));       
        f11.operation(new UnsharedConcreteFlyweight(&quot;第1次调用b。&quot;));       
        f12.operation(new UnsharedConcreteFlyweight(&quot;第2次调用b。&quot;));
    &#125;
&#125;
//非享元角色
class UnsharedConcreteFlyweight
&#123;
    private String info;
    UnsharedConcreteFlyweight(String info)
    &#123;
        this.info=info;
    &#125;
    public String getInfo()
    &#123;
        return info;
    &#125;
    public void setInfo(String info)
    &#123;
        this.info=info;
    &#125;
&#125;
//抽象享元角色
interface Flyweight
&#123;
    public void operation(UnsharedConcreteFlyweight state);
&#125;
//具体享元角色
class ConcreteFlyweight implements Flyweight
&#123;
    private String key;
    ConcreteFlyweight(String key)
    &#123;
        this.key=key;
        System.out.println(&quot;具体享元&quot;+key+&quot;被创建！&quot;);
    &#125;
    public void operation(UnsharedConcreteFlyweight outState)
    &#123;
        System.out.print(&quot;具体享元&quot;+key+&quot;被调用，&quot;);
        System.out.println(&quot;非享元信息是:&quot;+outState.getInfo());
    &#125;
&#125;
//享元工厂角色
class FlyweightFactory
&#123;
    private HashMap&lt;String, Flyweight&gt; flyweights=new HashMap&lt;String, Flyweight&gt;();
    public Flyweight getFlyweight(String key)
    &#123;
        Flyweight flyweight=(Flyweight)flyweights.get(key);
        if(flyweight!=null)
        &#123;
            System.out.println(&quot;具体享元&quot;+key+&quot;已经存在，被成功获取！&quot;);
        &#125;
        else
        &#123;
            flyweight=new ConcreteFlyweight(key);
            flyweights.put(key, flyweight);
        &#125;
        return flyweight;
    &#125;
&#125;

具体享元a被创建！
具体享元a已经存在，被成功获取！
具体享元a已经存在，被成功获取！
具体享元b被创建！
具体享元b已经存在，被成功获取！
具体享元a被调用，非享元信息是:第1次调用a。
具体享元a被调用，非享元信息是:第2次调用a。
具体享元a被调用，非享元信息是:第3次调用a。
具体享元b被调用，非享元信息是:第1次调用b。
具体享元b被调用，非享元信息是:第2次调用b。</code></pre>
<h4 id="享元模式的应用实例"><a href="#享元模式的应用实例" class="headerlink" title="享元模式的应用实例"></a>享元模式的应用实例</h4><p><strong>享元模式在五子棋游戏中的应用</strong> </p>
<p>五子棋同围棋一样，包含多个“黑”或“白”颜色的棋子，所以用享元模式比较好。 </p>
<p>本实例中的棋子（ChessPieces）类是抽象享元角色，它包含了一个落子的 DownPieces(Graphics g,Point pt) 方法；白子（WhitePieces）和黑子（BlackPieces）类是具体享元角色，它实现了落子方法；Point 是非享元角色，它指定了落子的位置；WeiqiFactory 是享元工厂角色，它通过 ArrayList 来管理棋子，并且提供了获取白子或者黑子的 getChessPieces(String type) 方法；客户类（Chessboard）利用 Graphics 组件在框架窗体中绘制一个棋盘，并实现 mouseClicked(MouseEvent e) 事件处理方法，该方法根据用户的选择从享元工厂中获取白子或者黑子并落在棋盘上。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E4%BA%94%E5%AD%90%E6%A3%8B%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package flyweight;
import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import javax.swing.*;
public class WzqGame
&#123;
    public static void main(String[] args)
    &#123;
        new Chessboard();
    &#125;
&#125;
//棋盘
class Chessboard extends MouseAdapter
&#123;
    WeiqiFactory wf;
    JFrame f;   
    Graphics g;
    JRadioButton wz;
    JRadioButton bz;
    private final int x=50;
    private final int y=50;
    private final int w=40;    //小方格宽度和高度
    private final int rw=400;    //棋盘宽度和高度
    Chessboard()
    &#123;
        wf=new WeiqiFactory();
        f=new JFrame(&quot;享元模式在五子棋游戏中的应用&quot;);
        f.setBounds(100,100,500,550);
        f.setVisible(true);       
        f.setResizable(false);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        JPanel SouthJP=new JPanel();
        f.add(&quot;South&quot;,SouthJP);
        wz=new JRadioButton(&quot;白子&quot;);
        bz=new JRadioButton(&quot;黑子&quot;,true);
        ButtonGroup group=new ButtonGroup();
        group.add(wz);
        group.add(bz);
        SouthJP.add(wz);
        SouthJP.add(bz);      
        JPanel CenterJP=new JPanel();
        CenterJP.setLayout(null);
        CenterJP.setSize(500, 500);
        CenterJP.addMouseListener(this);
        f.add(&quot;Center&quot;,CenterJP);      
        try
        &#123;
            Thread.sleep(500);
        &#125;
        catch(InterruptedException e)
        &#123;
            e.printStackTrace();
        &#125;               
        g=CenterJP.getGraphics();
        g.setColor(Color.BLUE);   
        g.drawRect(x, y, rw, rw);
        for(int i=1;i&lt;10;i++)
        &#123;
            //绘制第i条竖直线
            g.drawLine(x+(i*w),y,x+(i*w),y+rw);
            //绘制第i条水平线
            g.drawLine(x,y+(i*w),x+rw,y+(i*w));
        &#125;   
    &#125;
    public void mouseClicked(MouseEvent e)
    &#123;
        Point pt=new Point(e.getX()-15,e.getY()-15);
        if(wz.isSelected())
        &#123;
            ChessPieces c1=wf.getChessPieces(&quot;w&quot;);
            c1.DownPieces(g,pt);
        &#125;
        else if(bz.isSelected())
        &#123;
            ChessPieces c2=wf.getChessPieces(&quot;b&quot;);       
            c2.DownPieces(g,pt);  
        &#125;
    &#125;
&#125;
//抽象享元角色：棋子
interface ChessPieces
&#123;
    public void DownPieces(Graphics g,Point pt);    //下子
&#125;
//具体享元角色：白子
class WhitePieces implements ChessPieces
&#123;
    public void DownPieces(Graphics g,Point pt)
    &#123;       
        g.setColor(Color.WHITE);
        g.fillOval(pt.x,pt.y,30,30);
    &#125;
&#125;
//具体享元角色：黑子
class BlackPieces implements ChessPieces
&#123;
    public void DownPieces(Graphics g,Point pt)
    &#123;
        g.setColor(Color.BLACK);
        g.fillOval(pt.x,pt.y,30,30);
    &#125;
&#125;
//享元工厂角色
class WeiqiFactory
&#123;
    private ArrayList&lt;ChessPieces&gt; qz;   
    public WeiqiFactory()
    &#123;
        qz=new ArrayList&lt;ChessPieces&gt;();
        ChessPieces w=new WhitePieces();
        qz.add(w);
        ChessPieces b=new BlackPieces();
        qz.add(b);
    &#125;   
    public ChessPieces getChessPieces(String type)
    &#123;
        if(type.equalsIgnoreCase(&quot;w&quot;))
        &#123;
            return (ChessPieces)qz.get(0);
        &#125;
        else if(type.equalsIgnoreCase(&quot;b&quot;))
        &#123;
            return (ChessPieces)qz.get(1);
        &#125;
        else
        &#123;
            return null;
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="享元模式的应用场景"><a href="#享元模式的应用场景" class="headerlink" title="享元模式的应用场景"></a>享元模式的应用场景</h4><ol>
<li>系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。</li>
<li>大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。</li>
<li>由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。</li>
</ol>
<h4 id="享元模式的扩展"><a href="#享元模式的扩展" class="headerlink" title="享元模式的扩展"></a>享元模式的扩展</h4><p>(1) 单纯享元模式，这种享元模式中的所有的具体享元类都是可以共享的，不存在非共享的具体享元类 。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8D%95%E7%BA%AF%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<p>(2) 复合享元模式，这种享元模式中的有些享元对象是由一些单纯享元对象组合而成的，它们就是复合享元对象。虽然复合享元对象本身不能共享，但它们可以分解成单纯享元对象再被共享。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A4%8D%E5%90%88%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h3 id="7-组合（Composite）模式"><a href="#7-组合（Composite）模式" class="headerlink" title="7.组合（Composite）模式"></a>7.组合（Composite）模式</h3><p>在现实生活中，存在很多“部分-整体”的关系，例如，大学中的部门与学院、总公司中的部门与分公司、学习用品中的书与书包、生活用品中的衣月艮与衣柜以及厨房中的锅碗瓢盆等。在软件开发中也是这样，例如，文件系统中的文件与文件夹、窗体程序中的简单控件与容器控件等。对这些简单对象与复合对象的处理，如果用组合模式来实现会很方便。 </p>
<h4 id="组合模式的定义与特点"><a href="#组合模式的定义与特点" class="headerlink" title="组合模式的定义与特点"></a>组合模式的定义与特点</h4><p>组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。 </p>
<p>组合模式的主要优点有：</p>
<ol>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li>
<li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li>
</ol>
<p>其主要缺点是：</p>
<ol>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li>不容易用继承的方法来增加构件的新功能；</li>
</ol>
<h4 id="组合模式的结构与实现"><a href="#组合模式的结构与实现" class="headerlink" title="组合模式的结构与实现"></a>组合模式的结构与实现</h4><h5 id="1-模式的结构-9"><a href="#1-模式的结构-9" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</li>
<li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</li>
<li>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</li>
</ol>
<p>组合模式分为透明式的组合模式和安全式的组合模式。 </p>
<p>(1) 透明方式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E9%80%8F%E6%98%8E%E5%BC%8F%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<p>(2) 安全方式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AE%89%E5%85%A8%E5%BC%8F%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-9"><a href="#2-模式的实现-9" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><p> <strong>访问集合 c0={leaf1,{leaf2,leaf3}} 中的元素</strong> </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E9%9B%86%E5%90%88c0%E7%9A%84%E6%A0%91%E7%8A%B6%E5%9B%BE.gif"></p>
<pre><code class="java">package composite;
import java.util.ArrayList;
public class CompositePattern
&#123;
    public static void main(String[] args)
    &#123;
        Component c0=new Composite(); 
        Component c1=new Composite(); 
        Component leaf1=new Leaf(&quot;1&quot;); 
        Component leaf2=new Leaf(&quot;2&quot;); 
        Component leaf3=new Leaf(&quot;3&quot;);          
        c0.add(leaf1); 
        c0.add(c1);
        c1.add(leaf2); 
        c1.add(leaf3);          
        c0.operation(); 
    &#125;
&#125;
//抽象构件
interface Component
&#123;
    public void add(Component c);
    public void remove(Component c);
    public Component getChild(int i);
    public void operation();
&#125;
//树叶构件
class Leaf implements Component
&#123;
    private String name;
    public Leaf(String name)
    &#123;
        this.name=name;
    &#125;
    public void add(Component c)&#123; &#125;           
    public void remove(Component c)&#123; &#125;   
    public Component getChild(int i)
    &#123;
        return null;
    &#125;   
    public void operation()
    &#123;
        System.out.println(&quot;树叶&quot;+name+&quot;：被访问！&quot;); 
    &#125;
&#125;
//树枝构件
class Composite implements Component
&#123;
    private ArrayList&lt;Component&gt; children=new ArrayList&lt;Component&gt;();   
    public void add(Component c)
    &#123;
        children.add(c);
    &#125;   
    public void remove(Component c)
    &#123;
        children.remove(c);
    &#125;   
    public Component getChild(int i)
    &#123;
        return children.get(i);
    &#125;   
    public void operation()
    &#123;
        for(Object obj:children)
        &#123;
            ((Component)obj).operation();
        &#125;
    &#125;    
&#125;

树叶1：被访问！
树叶2：被访问！
树叶3：被访问！</code></pre>
<h4 id="组合模式的应用实例"><a href="#组合模式的应用实例" class="headerlink" title="组合模式的应用实例"></a>组合模式的应用实例</h4><p><strong>用组合模式实现当用户在商店购物后，显示其所选商品信息，并计算所选商品总价的功能</strong> </p>
<p>假如李先生到韶关“天街e角”生活用品店购物，用 1 个红色小袋子装了 2 包婺源特产（单价 7.9 元）、1 张婺源地图（单价 9.9 元）；用 1 个白色小袋子装了 2 包韶关香藉（单价 68 元）和 3 包韶关红茶（单价 180 元）；用 1 个中袋子装了前面的红色小袋子和 1 个景德镇瓷器（单价 380 元）；用 1 个大袋子装了前面的中袋子、白色小袋子和 1 双李宁牌运动鞋（单价 198 元）。 </p>
<p>最后“大袋子”中的内容有：{1 双李宁牌运动鞋（单价 198 元）、白色小袋子{2 包韶关香菇（单价 68 元）、3 包韶关红茶（单价 180 元）}、中袋子{1 个景德镇瓷器（单价 380 元）、红色小袋子{2 包婺源特产（单价 7.9 元）、1 张婺源地图（单价 9.9 元）}}}，现在要求编程显示李先生放在大袋子中的所有商品信息并计算要支付的总价。 </p>
<p>本实例可按安全组合模式设计: </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E9%9F%B6%E5%85%B3%E2%80%9C%E5%A4%A9%E8%A1%97e%E8%A7%92%E2%80%9D%E5%BA%97%E8%B4%AD%E7%89%A9%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package composite;
import java.util.ArrayList;
public class ShoppingTest
&#123;
    public static void main(String[] args)
    &#123;
        float s=0;
        Bags BigBag,mediumBag,smallRedBag,smallWhiteBag;
        Goods sp;
        BigBag=new Bags(&quot;大袋子&quot;);
        mediumBag=new Bags(&quot;中袋子&quot;);
        smallRedBag=new Bags(&quot;红色小袋子&quot;);
        smallWhiteBag=new Bags(&quot;白色小袋子&quot;);               
        sp=new Goods(&quot;婺源特产&quot;,2,7.9f);
        smallRedBag.add(sp);
        sp=new Goods(&quot;婺源地图&quot;,1,9.9f);
        smallRedBag.add(sp);       
        sp=new Goods(&quot;韶关香菇&quot;,2,68);
        smallWhiteBag.add(sp);
        sp=new Goods(&quot;韶关红茶&quot;,3,180);
        smallWhiteBag.add(sp);       
        sp=new Goods(&quot;景德镇瓷器&quot;,1,380);
        mediumBag.add(sp);
        mediumBag.add(smallRedBag);       
        sp=new Goods(&quot;李宁牌运动鞋&quot;,1,198);
        BigBag.add(sp);
        BigBag.add(smallWhiteBag);
        BigBag.add(mediumBag);
        System.out.println(&quot;您选购的商品有：&quot;);
        BigBag.show();
        s=BigBag.calculation();       
        System.out.println(&quot;要支付的总价是：&quot;+s+&quot;元&quot;);
    &#125;
&#125;
//抽象构件：物品
interface Articles
&#123;
    public float calculation(); //计算
    public void show();
&#125;
//树叶构件：商品
class Goods implements Articles
&#123;
    private String name;     //名字
    private int quantity;    //数量
    private float unitPrice; //单价
    public Goods(String name,int quantity,float unitPrice)
    &#123;
        this.name=name;
        this.quantity=quantity;
        this.unitPrice=unitPrice;
    &#125;   
    public float calculation()
    &#123;
        return quantity*unitPrice; 
    &#125;
    public void show()
    &#123;
        System.out.println(name+&quot;(数量：&quot;+quantity+&quot;，单价：&quot;+unitPrice+&quot;元)&quot;);
    &#125;
&#125;
//树枝构件：袋子
class Bags implements Articles
&#123;
    private String name;     //名字   
    private ArrayList&lt;Articles&gt; bags=new ArrayList&lt;Articles&gt;();   
    public Bags(String name)
    &#123;
        this.name=name;       
    &#125;
    public void add(Articles c)
    &#123;
        bags.add(c);
    &#125;   
    public void remove(Articles c)
    &#123;
        bags.remove(c);
    &#125;   
    public Articles getChild(int i)
    &#123;
        return bags.get(i);
    &#125;   
    public float calculation()
    &#123;
        float s=0;
        for(Object obj:bags)
        &#123;
            s+=((Articles)obj).calculation();
        &#125;
        return s;
    &#125;
    public void show()
    &#123;
        for(Object obj:bags)
        &#123;
            ((Articles)obj).show();
        &#125;
    &#125;
&#125;

您选购的商品有：
李宁牌运动鞋(数量：1，单价：198.0元)
韶关香菇(数量：2，单价：68.0元)
韶关红茶(数量：3，单价：180.0元)
景德镇瓷器(数量：1，单价：380.0元)
婺源特产(数量：2，单价：7.9元)
婺源地图(数量：1，单价：9.9元)
要支付的总价是：1279.7元</code></pre>
<h4 id="组合模式的应用场景"><a href="#组合模式的应用场景" class="headerlink" title="组合模式的应用场景"></a>组合模式的应用场景</h4><ol>
<li>在需要表示一个对象整体与部分的层次结构的场合。</li>
<li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。</li>
</ol>
<h4 id="组合模式的扩展"><a href="#组合模式的扩展" class="headerlink" title="组合模式的扩展"></a>组合模式的扩展</h4><p>如果对前面介绍的组合模式中的树叶节点和树枝节点进行抽象，也就是说树叶节点和树枝节点还有子节点，这时组合模式就扩展成复杂的组合模式了，如 JavaAWT/Swing中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A4%8D%E6%9D%82%E7%9A%84%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。 </p>
<h3 id="1-模板方法（Template-Method）模式"><a href="#1-模板方法（Template-Method）模式" class="headerlink" title="1.模板方法（Template Method）模式"></a>1.模板方法（Template Method）模式</h3><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。 </p>
<p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。 </p>
<p>这样的例子在生活中还有很多，例如，一个人每天会起床、吃饭、做事、睡觉等，其中“做事”的内容每天可能不同。我们把这些规定了流程或格式的实例定义成模板，允许使用者根据自己的需求去更新它，例如，简历模板、论文模板、Word 中模板文件等。 </p>
<h4 id="模式的定义与特点-4"><a href="#模式的定义与特点-4" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h4><p>模板方法（Template Method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。 </p>
<p>该模式的主要优点如下。</p>
<ol>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共的部分代码，便于代码复用。</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
</ol>
<p>该模式的主要缺点如下。</p>
<ol>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ol>
<h4 id="模式的结构与实现-4"><a href="#模式的结构与实现-4" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><p>模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及“不用调用我，让我来调用你”的反向控制技术。 </p>
<h5 id="1-模式的结构-10"><a href="#1-模式的结构-10" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><p>(1) 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。<br>① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>
<ul>
<li>抽象方法：在抽象类中申明，由具体子类实现。</li>
<li>具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>
<li>钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>
</ul>
<p>(2) 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-10"><a href="#2-模式的实现-10" class="headerlink" title="2.模式的实现"></a>2.模式的实现</h5><pre><code class="java">package templateMethod;
public class TemplateMethodPattern
&#123;
    public static void main(String[] args)
    &#123;
        AbstractClass tm=new ConcreteClass();
        tm.TemplateMethod();
    &#125;
&#125;
//抽象类
abstract class AbstractClass
&#123;
    public void TemplateMethod() //模板方法
    &#123;
        SpecificMethod();
        abstractMethod1();          
         abstractMethod2();
    &#125;  
    public void SpecificMethod() //具体方法
    &#123;
        System.out.println(&quot;抽象类中的具体方法被调用...&quot;);
    &#125;   
    public abstract void abstractMethod1(); //抽象方法1
    public abstract void abstractMethod2(); //抽象方法2
&#125;
//具体子类
class ConcreteClass extends AbstractClass
&#123;
    public void abstractMethod1()
    &#123;
        System.out.println(&quot;抽象方法1的实现被调用...&quot;);
    &#125;   
    public void abstractMethod2()
    &#123;
        System.out.println(&quot;抽象方法2的实现被调用...&quot;);
    &#125;
&#125;

抽象类中的具体方法被调用...
抽象方法1的实现被调用...
抽象方法2的实现被调用...</code></pre>
<h4 id="模式的应用实例-3"><a href="#模式的应用实例-3" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h4><p><strong>用模板方法模式实现出国留学手续设计程序</strong> </p>
<p>出国留学手续一般经过以下流程：索取学校资料，提出入学申请，办理因私出国护照、出境卡和公证，申请签证，体检、订机票、准备行装，抵达目标学校等，其中有些业务对各个学校是一样的，但有些业务因学校不同而不同，所以比较适合用模板方法模式来实现。 </p>
<p>在本实例中，我们先定义一个出国留学的抽象类 StudyAbroad，里面包含了一个模板方法 TemplateMethod()，该方法中包含了办理出国留学手续流程中的各个基本方法，其中有些方法的处理由于各国都一样，所以在抽象类中就可以实现，但有些方法的处理各国是不同的，必须在其具体子类（如美国留学类 StudyInAmerica）中实现。如果再增加一个国家，只要增加一个子类就可以了。</p>
<p> <img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%87%BA%E5%9B%BD%E7%95%99%E5%AD%A6%E6%89%8B%E7%BB%AD%E8%AE%BE%E8%AE%A1%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package templateMethod;
public class StudyAbroadProcess
&#123;
    public static void main(String[] args)
    &#123;
        StudyAbroad tm=new StudyInAmerica();
        tm.TemplateMethod();
    &#125;
&#125;
//抽象类: 出国留学
abstract class StudyAbroad
&#123;
    public void TemplateMethod() //模板方法
    &#123;
        LookingForSchool(); //索取学校资料
        ApplyForEnrol();    //入学申请      
        ApplyForPassport(); //办理因私出国护照、出境卡和公证
        ApplyForVisa();     //申请签证
        ReadyGoAbroad();    //体检、订机票、准备行装
        Arriving();         //抵达
    &#125;              
    public void ApplyForPassport()
    &#123;
        System.out.println(&quot;三.办理因私出国护照、出境卡和公证：&quot;);
        System.out.println(&quot;  1）持录取通知书、本人户口簿或身份证向户口所在地公安机关申请办理因私出国护照和出境卡。&quot;);
        System.out.println(&quot;  2）办理出生公证书，学历、学位和成绩公证，经历证书，亲属关系公证，经济担保公证。&quot;);
    &#125;
    public void ApplyForVisa()
    &#123;
        System.out.println(&quot;四.申请签证：&quot;);
        System.out.println(&quot;  1）准备申请国外境签证所需的各种资料，包括个人学历、成绩单、工作经历的证明；个人及家庭收入、资金和财产证明；家庭成员的关系证明等；&quot;);
        System.out.println(&quot;  2）向拟留学国家驻华使(领)馆申请入境签证。申请时需按要求填写有关表格，递交必需的证明材料，缴纳签证。有的国家(比如美国、英国、加拿大等)在申请签证时会要求申请人前往使(领)馆进行面试。&quot;);
    &#125;
    public void ReadyGoAbroad()
    &#123;
        System.out.println(&quot;五.体检、订机票、准备行装：&quot;);
        System.out.println(&quot;  1）进行身体检查、免疫检查和接种传染病疫苗；&quot;);
        System.out.println(&quot;  2）确定机票时间、航班和转机地点。&quot;);
    &#125;
    public abstract void LookingForSchool();//索取学校资料
    public abstract void ApplyForEnrol();   //入学申请
    public abstract void Arriving();        //抵达
&#125;
//具体子类: 美国留学
class StudyInAmerica extends StudyAbroad
&#123;
    @Override
    public void LookingForSchool()
    &#123;
        System.out.println(&quot;一.索取学校以下资料：&quot;);
        System.out.println(&quot;  1）对留学意向国家的政治、经济、文化背景和教育体制、学术水平进行较为全面的了解；&quot;);
        System.out.println(&quot;  2）全面了解和掌握国外学校的情况，包括历史、学费、学制、专业、师资配备、教学设施、学术地位、学生人数等；&quot;);
        System.out.println(&quot;  3）了解该学校的住宿、交通、医疗保险情况如何；&quot;);
        System.out.println(&quot;  4）该学校在中国是否有授权代理招生的留学中介公司？&quot;);
        System.out.println(&quot;  5）掌握留学签证情况；&quot;);
        System.out.println(&quot;  6）该国政府是否允许留学生合法打工？&quot;);
        System.out.println(&quot;  8）毕业之后可否移民？&quot;);
        System.out.println(&quot;  9）文凭是否受到我国认可？&quot;);
    &#125;
    @Override
    public void ApplyForEnrol()
    &#123;
        System.out.println(&quot;二.入学申请：&quot;);
        System.out.println(&quot;  1）填写报名表；&quot;);
        System.out.println(&quot;  2）将报名表、个人学历证明、最近的学习成绩单、推荐信、个人简历、托福或雅思语言考试成绩单等资料寄往所申请的学校；&quot;);
        System.out.println(&quot;  3）为了给签证办理留有充裕的时间，建议越早申请越好，一般提前1年就比较从容。&quot;);       
    &#125;
    @Override
    public void Arriving()
    &#123;
        System.out.println(&quot;六.抵达目标学校：&quot;);
        System.out.println(&quot;  1）安排住宿；&quot;);
        System.out.println(&quot;  2）了解校园及周边环境。&quot;);
    &#125;
&#125;

一.索取学校以下资料：
  1）对留学意向国家的政治、经济、文化背景和教育体制、学术水平进行较为全面的了解；
  2）全面了解和掌握国外学校的情况，包括历史、学费、学制、专业、师资配备、教学设施、学术地位、学生人数等；
  3）了解该学校的住宿、交通、医疗保险情况如何；
  4）该学校在中国是否有授权代理招生的留学中介公司？
  5）掌握留学签证情况；
  6）该国政府是否允许留学生合法打工？
  8）毕业之后可否移民？
  9）文凭是否受到我国认可？
二.入学申请：
  1）填写报名表；
  2）将报名表、个人学历证明、最近的学习成绩单、推荐信、个人简历、托福或雅思语言考试成绩单等资料寄往所申请的学校；
  3）为了给签证办理留有充裕的时间，建议越早申请越好，一般提前1年就比较从容。
三.办理因私出国护照、出境卡和公证：
  1）持录取通知书、本人户口簿或身份证向户口所在地公安机关申请办理因私出国护照和出境卡。
  2）办理出生公证书，学历、学位和成绩公证，经历证书，亲属关系公证，经济担保公证。
四.申请签证：
  1）准备申请国外境签证所需的各种资料，包括个人学历、成绩单、工作经历的证明；个人及家庭收入、资金和财产证明；家庭成员的关系证明等；
  2）向拟留学国家驻华使(领)馆申请入境签证。申请时需按要求填写有关表格，递交必需的证明材料，缴纳签证。有的国家(比如美国、英国、加拿大等)在申请签证时会要求申请人前往使(领)馆进行面试。
五.体检、订机票、准备行装：
  1）进行身体检查、免疫检查和接种传染病疫苗；
  2）确定机票时间、航班和转机地点。
六.抵达目标学校：
  1）安排住宿；
  2）了解校园及周边环境。</code></pre>
<h4 id="模式的应用场景-3"><a href="#模式的应用场景-3" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h4><ol>
<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>
<li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li>
<li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li>
</ol>
<h4 id="模式的扩展-3"><a href="#模式的扩展-3" class="headerlink" title="模式的扩展"></a>模式的扩展</h4><p>在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用“钩子方法”可以使得子类控制父类的行为。如下面例子中，可以通过在具体子类中重写钩子方法 HookMethod1() 和 HookMethod2() 来改变抽象父类中的运行结果。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%90%AB%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h3 id="2-策略（Strategy）模式"><a href="#2-策略（Strategy）模式" class="headerlink" title="2.策略（Strategy）模式"></a>2.策略（Strategy）模式</h3><p>在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车、骑自行车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。</p>
<p>在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。</p>
<p>如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。 </p>
<h4 id="策略模式的定义与特点"><a href="#策略模式的定义与特点" class="headerlink" title="策略模式的定义与特点"></a>策略模式的定义与特点</h4><p>策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。 </p>
<p>策略模式的主要优点如下。</p>
<ol>
<li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。</li>
<li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li>
<li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li>
<li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li>
<li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li>
</ol>
<p>其主要缺点如下。</p>
<ol>
<li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。</li>
<li>策略模式造成很多的策略类。</li>
</ol>
<h4 id="策略模式的结构与实现"><a href="#策略模式的结构与实现" class="headerlink" title="策略模式的结构与实现"></a>策略模式的结构与实现</h4><p>策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性，现在我们来分析其基本结构和实现方法。 </p>
<h5 id="1-模式的结构-11"><a href="#1-模式的结构-11" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-11"><a href="#2-模式的实现-11" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package strategy;
public class StrategyPattern
&#123;
    public static void main(String[] args)
    &#123;
        Context c=new Context();
        Strategy s=new ConcreteStrategyA();
        c.setStrategy(s);
        c.strategyMethod();
        System.out.println(&quot;-----------------&quot;);
        s=new ConcreteStrategyB();
        c.setStrategy(s);
        c.strategyMethod();
    &#125;
&#125;
//抽象策略类
interface Strategy
&#123;   
    public void strategyMethod();    //策略方法
&#125;
//具体策略类A
class ConcreteStrategyA implements Strategy
&#123;
    public void strategyMethod()
    &#123;
        System.out.println(&quot;具体策略A的策略方法被访问！&quot;);
    &#125;
&#125;
//具体策略类B
class ConcreteStrategyB implements Strategy
&#123;
  public void strategyMethod()
  &#123;
      System.out.println(&quot;具体策略B的策略方法被访问！&quot;);
  &#125;
&#125;
//环境类
class Context
&#123;
    private Strategy strategy;
    public Strategy getStrategy()
    &#123;
        return strategy;
    &#125;
    public void setStrategy(Strategy strategy)
    &#123;
        this.strategy=strategy;
    &#125;
    public void strategyMethod()
    &#123;
        strategy.strategyMethod();
    &#125;
&#125;

具体策略A的策略方法被访问！
-----------------
具体策略B的策略方法被访问！</code></pre>
<h4 id="策略模式的应用实例"><a href="#策略模式的应用实例" class="headerlink" title="策略模式的应用实例"></a>策略模式的应用实例</h4><p><strong>策略模式在“大闸蟹”做菜中的应用</strong> </p>
<p>关于大闸蟹的做法有很多种，我们以清蒸大闸蟹和红烧大闸蟹两种方法为例，介绍策略模式的应用。</p>
<p>首先，定义一个大闸蟹加工的抽象策略类（CrabCooking），里面包含了一个做菜的抽象方法 CookingMethod()；然后，定义清蒸大闸蟹（SteamedCrabs）和红烧大闸蟹（BraisedCrabs）的具体策略类，它们实现了抽象策略类中的抽象方法；由于本程序要显示做好的结果图，所以将具体策略类定义成 JLabel 的子类；最后，定义一个厨房（Kitchen）环境类，它具有设置和选择做菜策略的方法；客户类通过厨房类获取做菜策略，并把做菜结果图在窗体中显示出来。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A4%A7%E9%97%B8%E8%9F%B9%E5%81%9A%E8%8F%9C%E7%AD%96%E7%95%A5%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package strategy;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
public class CrabCookingStrategy implements ItemListener
&#123;
    private JFrame f;
    private JRadioButton qz,hs;
    private JPanel CenterJP,SouthJP;
    private Kitchen cf;    //厨房
    private CrabCooking qzx,hsx;    //大闸蟹加工者   
    CrabCookingStrategy()
    &#123;
        f=new JFrame(&quot;策略模式在大闸蟹做菜中的应用&quot;);
        f.setBounds(100,100,500,400);
        f.setVisible(true);       
        f.setResizable(false);
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        SouthJP=new JPanel();
        CenterJP=new JPanel();
        f.add(&quot;South&quot;,SouthJP);
        f.add(&quot;Center&quot;,CenterJP);
        qz=new JRadioButton(&quot;清蒸大闸蟹&quot;);
        hs=new JRadioButton(&quot;红烧大闸蟹&quot;);
        qz.addItemListener(this);
        hs.addItemListener(this);
        ButtonGroup group=new ButtonGroup();
        group.add(qz);
        group.add(hs);
        SouthJP.add(qz);
        SouthJP.add(hs);
        //---------------------------------
        cf=new Kitchen();    //厨房
        qzx=new SteamedCrabs();    //清蒸大闸蟹类
        hsx=new BraisedCrabs();    //红烧大闸蟹类
    &#125;
    public void itemStateChanged(ItemEvent e)
    &#123;
        JRadioButton jc=(JRadioButton) e.getSource();
        if(jc==qz)
        &#123;
            cf.setStrategy(qzx);
            cf.CookingMethod(); //清蒸
        &#125;
        else if(jc==hs)
        &#123;
            cf.setStrategy(hsx);
            cf.CookingMethod(); //红烧
        &#125;
        CenterJP.removeAll();
        CenterJP.repaint();
        CenterJP.add((Component)cf.getStrategy());       
        f.setVisible(true);
    &#125;
    public static void main(String[] args)
    &#123;       
        new CrabCookingStrategy();
    &#125;
&#125;
//抽象策略类：大闸蟹加工类
interface CrabCooking
&#123;
    public void CookingMethod();    //做菜方法
&#125;
//具体策略类：清蒸大闸蟹
class SteamedCrabs extends JLabel implements CrabCooking
&#123;
    private static final long serialVersionUID=1L;
    public void CookingMethod()
    &#123;
          this.setIcon(new ImageIcon(&quot;src/strategy/SteamedCrabs.jpg&quot;));
          this.setHorizontalAlignment(CENTER);
    &#125;
&#125;
//具体策略类：红烧大闸蟹
class BraisedCrabs extends JLabel implements CrabCooking
&#123;
    private static final long serialVersionUID=1L;
    public void CookingMethod()
    &#123;
        this.setIcon(new ImageIcon(&quot;src/strategy/BraisedCrabs.jpg&quot;));
        this.setHorizontalAlignment(CENTER);
    &#125;
&#125;
//环境类：厨房
class Kitchen
&#123;
    private CrabCooking strategy;    //抽象策略
    public void setStrategy(CrabCooking strategy)
    &#123;
        this.strategy=strategy;
    &#125;
    public CrabCooking getStrategy()
    &#123;
        return strategy;
    &#125;
    public void CookingMethod()
    &#123;
        strategy.CookingMethod();    //做菜   
    &#125;
&#125;</code></pre>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A4%A7%E9%97%B8%E8%9F%B9%E5%81%9A%E8%8F%9C%E7%BB%93%E6%9E%9C.jpg"></p>
<p><strong>用策略模式实现从韶关去婺源旅游的出行方式</strong> </p>
<p>从韶关去婺源旅游有以下几种出行方式：坐火车、坐汽车和自驾车，所以该实例用策略模式比较适合。</p>
<p> <img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A9%BA%E6%BA%90%E6%97%85%E6%B8%B8%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h4 id="策略模式的应用场景"><a href="#策略模式的应用场景" class="headerlink" title="策略模式的应用场景"></a>策略模式的应用场景</h4><p>策略模式在很多地方用到，如 Java</p>
<ol>
<li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li>
<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li>
<li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li>
<li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li>
<li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>
</ol>
<h4 id="策略模式的扩展"><a href="#策略模式的扩展" class="headerlink" title="策略模式的扩展"></a>策略模式的扩展</h4><p>在一个使用策略模式的系统中，当存在的策略很多时，客户端管理所有策略算法将变得很复杂，如果在环境类中使用策略工厂模式来管理这些策略类将大大减少客户端的工作复杂度。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%AD%96%E7%95%A5%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h3 id="3-命令（Command）模式"><a href="#3-命令（Command）模式" class="headerlink" title="3.命令（Command）模式"></a>3.命令（Command）模式</h3><p>在软件开发系统中，常常出现“方法的请求者”与“方法的实现者”之间存在紧密的耦合关系。这不利于软件功能的扩展与维护。例如，想对行为进行“撤销、重做、记录”等处理都很不方便，因此“如何将方法的请求者与方法的实现者解耦？”变得很重要，命令模式能很好地解决这个问题。</p>
<p>在现实生活中，这样的例子也很多，例如，电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者），还有计算机键盘上的“功能键”等。 </p>
<h4 id="命令模式的定义与特点"><a href="#命令模式的定义与特点" class="headerlink" title="命令模式的定义与特点"></a>命令模式的定义与特点</h4><p>命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p>
<p>命令模式的主要优点如下。</p>
<ol>
<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li>
<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>
<li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>
</ol>
<p>其缺点是：可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。 </p>
<h4 id="命令模式的结构与实现"><a href="#命令模式的结构与实现" class="headerlink" title="命令模式的结构与实现"></a>命令模式的结构与实现</h4><h5 id="1-模式的结构-12"><a href="#1-模式的结构-12" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li>
<li>具体命令角色（Concrete  Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li>
<li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-12"><a href="#2-模式的实现-12" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package command;
public class CommandPattern
&#123;
    public static void main(String[] args)
    &#123;
        Command cmd=new ConcreteCommand();
        Invoker ir=new Invoker(cmd);
        System.out.println(&quot;客户访问调用者的call()方法...&quot;);
        ir.call();
    &#125;
&#125;
//调用者
class Invoker
&#123;
    private Command command;
    public Invoker(Command command)
    &#123;
        this.command=command;
    &#125;
    public void setCommand(Command command)
    &#123;
        this.command=command;
    &#125;
    public void call()
    &#123;
        System.out.println(&quot;调用者执行命令command...&quot;);
        command.execute();
    &#125;
&#125;
//抽象命令
interface Command
&#123;
    public abstract void execute();
&#125;
//具体命令
class ConcreteCommand implements Command
&#123;
    private Receiver receiver;
    ConcreteCommand()
    &#123;
        receiver=new Receiver();
    &#125;
    public void execute()
    &#123;
        receiver.action();
    &#125;
&#125;
//接收者
class Receiver
&#123;
    public void action()
    &#123;
        System.out.println(&quot;接收者的action()方法被调用...&quot;);
    &#125;
&#125;

客户访问调用者的call()方法...
调用者执行命令command...
接收者的action()方法被调用...</code></pre>
<h4 id="命令模式的应用实例"><a href="#命令模式的应用实例" class="headerlink" title="命令模式的应用实例"></a>命令模式的应用实例</h4><p><strong>用命令模式实现客户去餐馆吃早餐的实例</strong> </p>
<p>客户去餐馆可选择的早餐有肠粉、河粉和馄饨等，客户可向服务员选择以上早餐中的若干种，服务员将客户的请求交给相关的厨师去做。这里的点早餐相当于“命令”，服务员相当于“调用者”，厨师相当于“接收者”，所以用命令模式实现比较合适。 </p>
<p>首先，定义一个早餐类（Breakfast），它是抽象命令类，有抽象方法 cooking()，说明要做什么；再定义其子类肠粉类（ChangFen）、馄饨类（HunTun）和河粉类（HeFen），它们是具体命令类，实现早餐类的 cooking() 方法，但它们不会具体做，而是交给具体的厨师去做；具体厨师类有肠粉厨师（ChangFenChef）、馄蚀厨师（HunTunChef）和河粉厨师（HeFenChef），他们是命令的接收者，由于本实例要显示厨师做菜的效果图，所以把每个厨师类定义为 JFrame 的子类；最后，定义服务员类（Waiter），它接收客户的做菜请求，并发出做菜的命令。客户类是通过服务员类来点菜的 。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AE%A2%E6%88%B7%E5%9C%A8%E9%A4%90%E9%A6%86%E5%90%83%E6%97%A9%E9%A4%90%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package command;
import javax.swing.*;
public class CookingCommand
&#123;
    public static void main(String[] args)
    &#123;
        Breakfast food1=new ChangFen();
        Breakfast food2=new HunTun();
        Breakfast food3=new HeFen();
        Waiter fwy=new Waiter();
        fwy.setChangFen(food1);//设置肠粉菜单
        fwy.setHunTun(food2);  //设置河粉菜单
        fwy.setHeFen(food3);   //设置馄饨菜单
        fwy.chooseChangFen();  //选择肠粉
        fwy.chooseHeFen();     //选择河粉
        fwy.chooseHunTun();    //选择馄饨
    &#125;
&#125;
//调用者：服务员
class Waiter
&#123;
    private Breakfast changFen,hunTun,heFen;
    public void setChangFen(Breakfast f)
    &#123;
        changFen=f;
    &#125;
    public void setHunTun(Breakfast f)
    &#123;
        hunTun=f;
    &#125;
    public void setHeFen(Breakfast f)
    &#123;
        heFen=f;
    &#125;
    public void chooseChangFen()
    &#123;
        changFen.cooking();
    &#125;
    public void chooseHunTun()
    &#123;
        hunTun.cooking();
    &#125;
    public void chooseHeFen()
    &#123;
        heFen.cooking();
    &#125;
&#125;
//抽象命令：早餐
interface Breakfast
&#123;
    public abstract void cooking();
&#125;
//具体命令：肠粉
class ChangFen implements Breakfast
&#123;
    private ChangFenChef receiver;
    ChangFen()
    &#123;
        receiver=new ChangFenChef();
    &#125;
    public void cooking()
    &#123;       
        receiver.cooking();
    &#125;
&#125;
//具体命令：馄饨
class HunTun implements Breakfast
&#123;
    private HunTunChef receiver;
    HunTun()
    &#123;
        receiver=new HunTunChef();
    &#125;
    public void cooking()
    &#123;
        receiver.cooking();
    &#125;
&#125;
//具体命令：河粉
class HeFen implements Breakfast
&#123;
    private HeFenChef receiver;
    HeFen()
    &#123;
        receiver=new HeFenChef();
    &#125;
    public void cooking()
    &#123;
        receiver.cooking();
    &#125;
&#125;
//接收者：肠粉厨师
class ChangFenChef extends JFrame
&#123;   
    private static final long serialVersionUID = 1L;
    JLabel l=new JLabel();
    ChangFenChef()
    &#123;
        super(&quot;煮肠粉&quot;);
        l.setIcon(new ImageIcon(&quot;src/command/ChangFen.jpg&quot;));
        this.add(l);
        this.setLocation(30, 30);
        this.pack();
        this.setResizable(false);
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);   
    &#125;
    public void cooking()
    &#123;
        this.setVisible(true);
    &#125;
&#125;
//接收者：馄饨厨师
class HunTunChef extends JFrame
&#123;
    private static final long serialVersionUID=1L;
    JLabel l=new JLabel();
    HunTunChef()
    &#123;
        super(&quot;煮馄饨&quot;);
        l.setIcon(new ImageIcon(&quot;src/command/HunTun.jpg&quot;));
        this.add(l);
        this.setLocation(350, 50);
        this.pack();
        this.setResizable(false);
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    
    &#125;
    public void cooking()
    &#123;
        this.setVisible(true);
    &#125;
&#125;
//接收者：河粉厨师
class HeFenChef extends JFrame
&#123;
    private static final long serialVersionUID=1L;
    JLabel l=new JLabel();
    HeFenChef()
    &#123;
        super(&quot;煮河粉&quot;);
        l.setIcon(new ImageIcon(&quot;src/command/HeFen.jpg&quot;));
        this.add(l);
        this.setLocation(200, 280);
        this.pack();
        this.setResizable(false);
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;
    public void cooking()
    &#123;
        this.setVisible(true);
    &#125;
&#125;</code></pre>
<h4 id="命令模式的应用场景"><a href="#命令模式的应用场景" class="headerlink" title="命令模式的应用场景"></a>命令模式的应用场景</h4><ol>
<li>当系统需要将请求调用者与请求接收者解耦时，命令模式使得调用者和接收者不直接交互。</li>
<li>当系统需要随机请求命令或经常增加或删除命令时，命令模式比较方便实现这些功能。</li>
<li>当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。</li>
<li>当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。</li>
</ol>
<h4 id="命令模式的扩展"><a href="#命令模式的扩展" class="headerlink" title="命令模式的扩展"></a>命令模式的扩展</h4><p>在软件开发中，有时将命令模式与前面学的组合模式联合使用，这就构成了宏命令模式，也叫组合命令模式。宏命令包含了一组命令，它充当了具体命令与调用者的双重角色，执行它时将递归调用它所包含的所有命令。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%BB%84%E5%90%88%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package command;
import java.util.ArrayList;
public class CompositeCommandPattern
&#123;
    public static void main(String[] args)
    &#123;
        AbstractCommand cmd1=new ConcreteCommand1();
        AbstractCommand cmd2=new ConcreteCommand2();
        CompositeInvoker ir=new CompositeInvoker();
        ir.add(cmd1);
        ir.add(cmd2);
        System.out.println(&quot;客户访问调用者的execute()方法...&quot;);
        ir.execute();
    &#125;
&#125;
//抽象命令
interface AbstractCommand
&#123;
    public abstract void execute();
&#125;
//树叶构件: 具体命令1
class ConcreteCommand1 implements AbstractCommand
&#123;
    private CompositeReceiver receiver;
    ConcreteCommand1()
    &#123;
        receiver=new CompositeReceiver();
    &#125;
    public void execute()
    &#123;       
        receiver.action1();
    &#125;
&#125;
//树叶构件: 具体命令2
class ConcreteCommand2 implements AbstractCommand
&#123;
    private CompositeReceiver receiver;
    ConcreteCommand2()
    &#123;
        receiver=new CompositeReceiver();
    &#125;
    public void execute()
    &#123;       
        receiver.action2();
    &#125;
&#125;
//树枝构件: 调用者
class CompositeInvoker implements AbstractCommand
&#123;
    private ArrayList&lt;AbstractCommand&gt; children = new ArrayList&lt;AbstractCommand&gt;();   
    public void add(AbstractCommand c)
    &#123;
        children.add(c);
    &#125;   
    public void remove(AbstractCommand c)
    &#123;
        children.remove(c);
    &#125;   
    public AbstractCommand getChild(int i)
    &#123;
        return children.get(i);
    &#125;   
    public void execute()
    &#123;
        for(Object obj:children)
        &#123;
            ((AbstractCommand)obj).execute();
        &#125;
    &#125;    
&#125;
//接收者
class CompositeReceiver
&#123;
    public void action1()
    &#123;
        System.out.println(&quot;接收者的action1()方法被调用...&quot;);
    &#125;
    public void action2()
    &#123;
        System.out.println(&quot;接收者的action2()方法被调用...&quot;);
    &#125;
&#125;

客户访问调用者的execute()方法...
接收者的action1()方法被调用...
接收者的action2()方法被调用...</code></pre>
<blockquote>
<p> 命令模式还可以同备忘录（Memento）模式组合使用，这样就变成了可撤销的命令模式 </p>
</blockquote>
<h3 id="4-责任链（Chain-of-Responsibility）模式"><a href="#4-责任链（Chain-of-Responsibility）模式" class="headerlink" title="4.责任链（Chain of Responsibility）模式"></a>4.责任链（Chain of Responsibility）模式</h3><p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。 </p>
<p>在计算机软硬件中也有相关例子，如总线网中数据报传送，每台计算机根据目标地址是否同自己的地址相同来决定是否接收；还有异常处理中，处理程序根据异常的类型决定自己是否处理该异常；还有 Struts2的拦截器、JSP 和 Servlet的 Filter 等，所有这些，如果用责任链模式都能很好解决。 </p>
<h4 id="模式的定义与特点-5"><a href="#模式的定义与特点-5" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h4><p>责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。 </p>
<blockquote>
<p>责任链模式也叫职责链模式。 </p>
</blockquote>
<p>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。 </p>
<p>责任链模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li>
<li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li>
<li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。</li>
<li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li>
<li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li>
</ol>
<p>其主要缺点如下。</p>
<ol>
<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li>
<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li>
</ol>
<h4 id="模式的结构与实现-5"><a href="#模式的结构与实现-5" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><p> 通常情况下，可以通过数据链表来实现职责链模式的数据结构。 </p>
<h5 id="1-模式的结构-13"><a href="#1-模式的结构-13" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><p>职责链模式主要包含以下角色。</p>
<ol>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ol>
<p>其结构图如图 1 所示。客户端可按图 2 所示设置责任链。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E8%B4%A3%E4%BB%BB%E9%93%BE.gif"></p>
<h5 id="2-模式的实现-13"><a href="#2-模式的实现-13" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package chainOfResponsibility;
public class ChainOfResponsibilityPattern
&#123;
    public static void main(String[] args)
    &#123;
        //组装责任链 
        Handler handler1=new ConcreteHandler1(); 
        Handler handler2=new ConcreteHandler2(); 
        handler1.setNext(handler2); 
        //提交请求 
        handler1.handleRequest(&quot;two&quot;);
    &#125;
&#125;
//抽象处理者角色
abstract class Handler
&#123;
    private Handler next;
    public void setNext(Handler next)
    &#123;
        this.next=next; 
    &#125;
    public Handler getNext()
    &#123; 
        return next; 
    &#125;   
    //处理请求的方法
    public abstract void handleRequest(String request);       
&#125;
//具体处理者角色1
class ConcreteHandler1 extends Handler
&#123;
    public void handleRequest(String request)
    &#123;
        if(request.equals(&quot;one&quot;)) 
        &#123;
            System.out.println(&quot;具体处理者1负责处理该请求！&quot;);       
        &#125;
        else
        &#123;
            if(getNext()!=null) 
            &#123;
                getNext().handleRequest(request);             
            &#125;
            else
            &#123;
                System.out.println(&quot;没有人处理该请求！&quot;);
            &#125;
        &#125; 
    &#125; 
&#125;
//具体处理者角色2
class ConcreteHandler2 extends Handler
&#123;
    public void handleRequest(String request)
    &#123;
        if(request.equals(&quot;two&quot;)) 
        &#123;
            System.out.println(&quot;具体处理者2负责处理该请求！&quot;);       
        &#125;
        else
        &#123;
            if(getNext()!=null) 
            &#123;
                getNext().handleRequest(request);             
            &#125;
            else
            &#123;
                System.out.println(&quot;没有人处理该请求！&quot;);
            &#125;
        &#125; 
    &#125;
&#125;

具体处理者2负责处理该请求！</code></pre>
<h4 id="模式的应用实例-4"><a href="#模式的应用实例-4" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h4><p><strong>用责任链模式设计一个请假条审批模块</strong> </p>
<p>假如规定学生请假小于或等于 2 天，班主任可以批准；小于或等于 7 天，系主任可以批准；小于或等于 10 天，院长可以批准；其他情况不予批准；这个实例适合使用职责链模式实现。 </p>
<p>首先，定义一个领导类（Leader），它是抽象处理者，包含了一个指向下一位领导的指针 next 和一个处理假条的抽象处理方法 handleRequest(int LeaveDays)；然后，定义班主任类（ClassAdviser）、系主任类（DepartmentHead）和院长类（Dean），它们是抽象处理者的子类，是具体处理者，必须根据自己的权力去实现父类的 handleRequest(int LeaveDays) 方法，如果无权处理就将假条交给下一位具体处理者，直到最后；客户类负责创建处理链，并将假条交给链头的具体处理者（班主任）。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E8%AF%B7%E5%81%87%E6%9D%A1%E5%AE%A1%E6%89%B9%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package chainOfResponsibility;
public class LeaveApprovalTest
&#123;
    public static void main(String[] args)
    &#123;
        //组装责任链 
        Leader teacher1=new ClassAdviser();
        Leader teacher2=new DepartmentHead();
        Leader teacher3=new Dean();
        //Leader teacher4=new DeanOfStudies();
        teacher1.setNext(teacher2);
        teacher2.setNext(teacher3);
        //teacher3.setNext(teacher4);
        //提交请求 
        teacher1.handleRequest(8);
    &#125;
&#125;
//抽象处理者：领导类
abstract class Leader
&#123;
    private Leader next;
    public void setNext(Leader next)
    &#123;
        this.next=next; 
    &#125;
    public Leader getNext()
    &#123; 
        return next; 
    &#125;   
    //处理请求的方法
    public abstract void handleRequest(int LeaveDays);       
&#125;
//具体处理者1：班主任类
class ClassAdviser extends Leader
&#123;
    public void handleRequest(int LeaveDays)
    &#123;
        if(LeaveDays&lt;=2) 
        &#123;
            System.out.println(&quot;班主任批准您请假&quot; + LeaveDays + &quot;天。&quot;);       
        &#125;
        else
        &#123;
            if(getNext() != null) 
            &#123;
                getNext().handleRequest(LeaveDays);             
            &#125;
            else
            &#123;
                  System.out.println(&quot;请假天数太多，没有人批准该假条！&quot;);
            &#125;
        &#125; 
    &#125; 
&#125;
//具体处理者2：系主任类
class DepartmentHead extends Leader
&#123;
    public void handleRequest(int LeaveDays)
    &#123;
        if(LeaveDays&lt;=7) 
        &#123;
            System.out.println(&quot;系主任批准您请假&quot; + LeaveDays + &quot;天。&quot;);       
        &#125;
        else
        &#123;
            if(getNext() != null) 
            &#123;
                  getNext().handleRequest(LeaveDays);             
            &#125;
            else
            &#123;
                System.out.println(&quot;请假天数太多，没有人批准该假条！&quot;);
           &#125;
        &#125; 
    &#125; 
&#125;
//具体处理者3：院长类
class Dean extends Leader
&#123;
    public void handleRequest(int LeaveDays)
    &#123;
        if(LeaveDays&lt;=10) 
        &#123;
            System.out.println(&quot;院长批准您请假&quot; + LeaveDays + &quot;天。&quot;);       
        &#125;
        else
        &#123;
              if(getNext() != null) 
            &#123;
                getNext().handleRequest(LeaveDays);             
            &#125;
            else
            &#123;
                  System.out.println(&quot;请假天数太多，没有人批准该假条！&quot;);
            &#125;
        &#125; 
    &#125; 
&#125;
//具体处理者4：教务处长类
class DeanOfStudies extends Leader
&#123;
    public void handleRequest(int LeaveDays)
    &#123;
        if(LeaveDays&lt;=20) 
        &#123;
            System.out.println(&quot;教务处长批准您请假&quot;+LeaveDays+&quot;天。&quot;);       
        &#125;
        else
        &#123;
              if(getNext()!=null) 
            &#123;
                getNext().handleRequest(LeaveDays);          
            &#125;
            else
            &#123;
                  System.out.println(&quot;请假天数太多，没有人批准该假条！&quot;);
            &#125;
        &#125; 
    &#125; 
&#125;

院长批准您请假8天。</code></pre>
<p>假如增加一个教务处长类，可以批准学生请假 20 天，也非常简单，代码如下： </p>
<pre><code class="java">//具体处理者4:教务处长类
class DeanOfStudies extends Leader
&#123;
    public void handleRequest(int LeaveDays)
    &#123;
        if(LeaveDays&lt;=20)
        &#123;
            System.out.println(&quot;教务处长批准您请假&quot;+LeaveDays+&quot;天。&quot;);
        &#125;
        else
        &#123;
            if(getNext()!=null)
            &#123;
                getNext().handleRequest(LeaveDays);
            &#125;
            else
            &#123;
                System.out.println(&quot;请假天数太多，没有人批准该假条！&quot;);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="模式的应用场景-4"><a href="#模式的应用场景-4" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h4><ol>
<li>有多个对象可以处理一个请求，哪个对象处理该请求由运行时刻自动确定。</li>
<li>可动态指定一组对象处理请求，或添加新的处理者。</li>
<li>在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。</li>
</ol>
<h4 id="模式的扩展-4"><a href="#模式的扩展-4" class="headerlink" title="模式的扩展"></a>模式的扩展</h4><ol>
<li>纯的职责链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。</li>
<li>不纯的职责链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。</li>
</ol>
<h3 id="5-状态（State）模式"><a href="#5-状态（State）模式" class="headerlink" title="5.状态（State）模式"></a>5.状态（State）模式</h3><p>在软件开发过程中，应用程序中的有些对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。当有状态的对象与外部事件产生互动时，其内部状态会发生改变，从而使得其行为也随之发生改变。如人的情绪有高兴的时候和伤心的时候，不同的情绪有不同的行为，当然外界也会影响其情绪变化。 </p>
<p>对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 语句来做状态判断，再进行不同情况的处理。但当对象的状态很多时，程序会变得很复杂。而且增加新的状态要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展。 </p>
<p>以上问题如果采用“状态模式”就能很好地得到解决。状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，放到一系列的状态类当中，这样可以把原来复杂的逻辑判断简单化。 </p>
<h4 id="状态模式的定义与特点"><a href="#状态模式的定义与特点" class="headerlink" title="状态模式的定义与特点"></a>状态模式的定义与特点</h4><p>状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。 </p>
<p>状态模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li>
<li>减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li>
<li>有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li>
</ol>
<p>状态模式的主要缺点如下。</p>
<ol>
<li>状态模式的使用必然会增加系统的类与对象的个数。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li>
</ol>
<h4 id="状态模式的结构与实现"><a href="#状态模式的结构与实现" class="headerlink" title="状态模式的结构与实现"></a>状态模式的结构与实现</h4><p>状态模式把受环境改变的对象行为包装在不同的状态对象里，其意图是让一个对象在其内部状态改变的时候，其行为也随之改变。 </p>
<h5 id="1-模式的结构-14"><a href="#1-模式的结构-14" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li>
<li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li>
<li>具体状态（Concrete  State）角色：实现抽象状态所对应的行为。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-14"><a href="#2-模式的实现-14" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package state;
public class StatePatternClient
&#123;
    public static void main(String[] args)
    &#123;       
        Context context=new Context();    //创建环境       
        context.Handle();    //处理请求
        context.Handle();
        context.Handle();
        context.Handle();
    &#125;
&#125;
//环境类
class Context
&#123;
    private State state;
    //定义环境类的初始状态
    public Context()
    &#123;
        this.state=new ConcreteStateA();
    &#125;
    //设置新状态
    public void setState(State state)
    &#123;
        this.state=state;
    &#125;
    //读取状态
    public State getState()
    &#123;
        return(state);
    &#125;
    //对请求做处理
    public void Handle()
    &#123;
        state.Handle(this);
    &#125;
&#125;
//抽象状态类
abstract class State
&#123;
    public abstract void Handle(Context context);
&#125;
//具体状态A类
class ConcreteStateA extends State
&#123;
    public void Handle(Context context)
    &#123;
        System.out.println(&quot;当前状态是 A.&quot;);
        context.setState(new ConcreteStateB());
    &#125;
&#125;
//具体状态B类
class ConcreteStateB extends State
&#123;
    public void Handle(Context context)
    &#123;
        System.out.println(&quot;当前状态是 B.&quot;);
        context.setState(new ConcreteStateA());
    &#125;
&#125;

当前状态是 A.
当前状态是 B.
当前状态是 A.
当前状态是 B.</code></pre>
<h4 id="状态模式的应用实例"><a href="#状态模式的应用实例" class="headerlink" title="状态模式的应用实例"></a>状态模式的应用实例</h4><p><strong>用“状态模式”设计一个学生成绩的状态转换程序</strong> </p>
<p>本实例包含了“不及格”“中等”和“优秀” 3 种状态，当学生的分数小于 60 分时为“不及格”状态，当分数大于等于 60 分且小于 90 分时为“中等”状态，当分数大于等于 90 分时为“优秀”状态，我们用状态模式来实现这个程序。 </p>
<p>首先，定义一个抽象状态类（AbstractState），其中包含了环境属性、状态名属性和当前分数属性，以及加减分方法 addScore(intx) 和检查当前状态的抽象方法 checkState()；然后，定义“不及格”状态类 LowState、“中等”状态类 MiddleState 和“优秀”状态类 HighState，它们是具体状态类，实现 checkState() 方法，负责检査自己的状态，并根据情况转换；最后，定义环境类（ScoreContext），其中包含了当前状态对象和加减分的方法 add(int score)，客户类通过该方法来改变成绩状态。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package state;
public class ScoreStateTest
&#123;
    public static void main(String[] args)
    &#123;
        ScoreContext account=new ScoreContext();
        System.out.println(&quot;学生成绩状态测试：&quot;);
        account.add(30);
        account.add(40);
        account.add(25);
        account.add(-15);
        account.add(-25);
    &#125;
&#125;
//环境类
class ScoreContext
&#123;
    private AbstractState state;
    ScoreContext()
    &#123;
        state=new LowState(this);
    &#125;
    public void setState(AbstractState state)
    &#123;
        this.state=state;
    &#125;
    public AbstractState getState()
    &#123;
        return state;
    &#125;   
    public void add(int score)
    &#123;
        state.addScore(score);
    &#125;
&#125;
//抽象状态类
abstract class AbstractState
&#123;
    protected ScoreContext hj;  //环境
    protected String stateName; //状态名
    protected int score; //分数
    public abstract void checkState(); //检查当前状态
    public void addScore(int x)
    &#123;
        score+=x;       
        System.out.print(&quot;加上：&quot;+x+&quot;分，\t当前分数：&quot;+score );
        checkState();
        System.out.println(&quot;分，\t当前状态：&quot;+hj.getState().stateName);
    &#125;   
&#125;
//具体状态类：不及格
class LowState extends AbstractState
&#123;
    public LowState(ScoreContext h)
    &#123;
        hj=h;
        stateName=&quot;不及格&quot;;
        score=0;
    &#125;
    public LowState(AbstractState state)
    &#123;
        hj=state.hj;
        stateName=&quot;不及格&quot;;
        score=state.score;
    &#125;
    public void checkState()
    &#123;
        if(score&gt;=90)
        &#123;
            hj.setState(new HighState(this));
        &#125;
        else if(score&gt;=60)
        &#123;
            hj.setState(new MiddleState(this));
        &#125;
    &#125;   
&#125;
//具体状态类：中等
class MiddleState extends AbstractState
&#123;
    public MiddleState(AbstractState state)
    &#123;
        hj=state.hj;
        stateName=&quot;中等&quot;;
        score=state.score;
    &#125;
    public void checkState()
    &#123;
        if(score&lt;60)
        &#123;
            hj.setState(new LowState(this));
        &#125;
        else if(score&gt;=90)
        &#123;
            hj.setState(new HighState(this));
        &#125;
    &#125;
&#125;
//具体状态类：优秀
class HighState extends AbstractState
&#123;
    public HighState(AbstractState state)
    &#123;
        hj=state.hj;
        stateName=&quot;优秀&quot;;
        score=state.score;
    &#125;           
    public void checkState()
    &#123;
        if(score&lt;60)
        &#123;
            hj.setState(new LowState(this));
        &#125;
        else if(score&lt;90)
        &#123;
            hj.setState(new MiddleState(this));
        &#125;
    &#125;
&#125;

学生成绩状态测试：
加上：30分，    当前分数：30分，    当前状态：不及格
加上：40分，    当前分数：70分，    当前状态：中等
加上：25分，    当前分数：95分，    当前状态：优秀
加上：-15分，    当前分数：80分，    当前状态：中等
加上：-25分，    当前分数：55分，    当前状态：不及格</code></pre>
<p><strong>用“状态模式”设计一个多线程的状态转换程序</strong> </p>
<p>多线程存在 5 种状态，分别为新建状态、就绪状态、运行状态、阻塞状态和死亡状态，各个状态当遇到相关方法调用或事件触发时会转换到其他状态，其状态转换规律如下图所示。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.gif"></p>
<p>现在先定义一个抽象状态类（TheadState），然后为图 3 所示的每个状态设计一个具体状态类，它们是新建状态（New）、就绪状态（Runnable ）、运行状态（Running）、阻塞状态（Blocked）和死亡状态（Dead），每个状态中有触发它们转变状态的方法，环境类（ThreadContext）中先生成一个初始状态（New），并提供相关触发方法。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package state;
public class ThreadStateTest
&#123;
    public static void main(String[] args)
    &#123;
        ThreadContext context=new ThreadContext();
        context.start();
        context.getCPU();
        context.suspend();
        context.resume();
        context.getCPU();
        context.stop();
    &#125;
&#125;
//环境类
class ThreadContext
&#123;
    private ThreadState state;
    ThreadContext()
    &#123;
        state=new New();
    &#125;
    public void setState(ThreadState state)
    &#123;
        this.state=state;
    &#125;
    public ThreadState getState()
    &#123;
        return state;
    &#125;   
    public void start()
    &#123;
        ((New) state).start(this);
    &#125;
    public void getCPU()
    &#123;
        ((Runnable) state).getCPU(this);
    &#125;
    public void suspend()
    &#123;
        ((Running) state).suspend(this);
    &#125;
    public void stop()
    &#123;
        ((Running) state).stop(this);
    &#125;
    public void resume()
    &#123;
        ((Blocked) state).resume(this);
    &#125;
&#125;
//抽象状态类：线程状态
abstract class ThreadState
&#123;
    protected String stateName; //状态名
&#125;
//具体状态类：新建状态
class New extends ThreadState
&#123;
    public New()
    &#123;       
        stateName=&quot;新建状态&quot;;
        System.out.println(&quot;当前线程处于：新建状态.&quot;);   
    &#125;
    public void start(ThreadContext hj)
    &#123;
        System.out.print(&quot;调用start()方法--&gt;&quot;);
        if(stateName.equals(&quot;新建状态&quot;))
        &#123;
            hj.setState(new Runnable());
        &#125;
        else
        &#123;
            System.out.println(&quot;当前线程不是新建状态，不能调用start()方法.&quot;);
        &#125;
    &#125;   
&#125;
//具体状态类：就绪状态
class Runnable extends ThreadState
&#123;
    public Runnable()
    &#123;       
        stateName=&quot;就绪状态&quot;;
        System.out.println(&quot;当前线程处于：就绪状态.&quot;);   
    &#125;
    public void getCPU(ThreadContext hj)
    &#123;
        System.out.print(&quot;获得CPU时间--&gt;&quot;);
        if(stateName.equals(&quot;就绪状态&quot;))
        &#123;
            hj.setState(new Running());
        &#125;
        else
        &#123;
            System.out.println(&quot;当前线程不是就绪状态，不能获取CPU.&quot;);
        &#125;
    &#125;   
&#125;
//具体状态类：运行状态
class Running extends ThreadState
&#123;
    public Running()
    &#123;       
        stateName=&quot;运行状态&quot;;
        System.out.println(&quot;当前线程处于：运行状态.&quot;);   
    &#125;
    public void suspend(ThreadContext hj)
    &#123;
        System.out.print(&quot;调用suspend()方法--&gt;&quot;);
        if(stateName.equals(&quot;运行状态&quot;))
        &#123;
            hj.setState(new Blocked());
        &#125;
        else
        &#123;
            System.out.println(&quot;当前线程不是运行状态，不能调用suspend()方法.&quot;);
        &#125;
    &#125;
    public void stop(ThreadContext hj)
    &#123;
        System.out.print(&quot;调用stop()方法--&gt;&quot;);
        if(stateName.equals(&quot;运行状态&quot;))
        &#123;
            hj.setState(new Dead());
        &#125;
        else
        &#123;
            System.out.println(&quot;当前线程不是运行状态，不能调用stop()方法.&quot;);
        &#125;
    &#125;
&#125;
//具体状态类：阻塞状态
class Blocked extends ThreadState
&#123;
    public Blocked()
    &#123;       
        stateName=&quot;阻塞状态&quot;;
        System.out.println(&quot;当前线程处于：阻塞状态.&quot;);   
    &#125;
    public void resume(ThreadContext hj)
    &#123;
        System.out.print(&quot;调用resume()方法--&gt;&quot;);
        if(stateName.equals(&quot;阻塞状态&quot;))
        &#123;
            hj.setState(new Runnable());
        &#125;
        else
        &#123;
            System.out.println(&quot;当前线程不是阻塞状态，不能调用resume()方法.&quot;);
        &#125;
    &#125;   
&#125;
//具体状态类：死亡状态
class Dead extends ThreadState
&#123;
    public Dead()
    &#123;
        stateName=&quot;死亡状态&quot;;
        System.out.println(&quot;当前线程处于：死亡状态.&quot;);   
    &#125;   
&#125;

当前线程处于：新建状态.
调用start()方法--&gt;当前线程处于：就绪状态.
获得CPU时间--&gt;当前线程处于：运行状态.
调用suspend()方法--&gt;当前线程处于：阻塞状态.
调用resume()方法--&gt;当前线程处于：就绪状态.
获得CPU时间--&gt;当前线程处于：运行状态.
调用stop()方法--&gt;当前线程处于：死亡状态.</code></pre>
<h4 id="状态模式的应用场景"><a href="#状态模式的应用场景" class="headerlink" title="状态模式的应用场景"></a>状态模式的应用场景</h4><ul>
<li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li>
<li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li>
</ul>
<h4 id="状态模式的扩展"><a href="#状态模式的扩展" class="headerlink" title="状态模式的扩展"></a>状态模式的扩展</h4><p>在有些情况下，可能有多个环境对象需要共享一组状态，这时需要引入享元模式，将这些具体状态对象放在集合中供程序共享。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<p>共享状态模式的不同之处是在环境类中增加了一个 HashMap 来保存相关状态，当需要某种状态时可以从中获取。</p>
<pre><code class="java">package state;
import java.util.HashMap;
public class FlyweightStatePattern
&#123;
    public static void main(String[] args)
    &#123;
        ShareContext context=new ShareContext(); //创建环境       
        context.Handle(); //处理请求
        context.Handle();
        context.Handle();
        context.Handle();
    &#125;
&#125;
//环境类
class ShareContext
&#123;
    private ShareState state;
    private HashMap&lt;String, ShareState&gt; stateSet=new HashMap&lt;String, ShareState&gt;();
    public ShareContext()
    &#123;
        state=new ConcreteState1();
        stateSet.put(&quot;1&quot;, state);
        state=new ConcreteState2();
        stateSet.put(&quot;2&quot;, state);
        state=getState(&quot;1&quot;);
    &#125;
    //设置新状态
    public void setState(ShareState state)
    &#123;
        this.state=state;
    &#125;
    //读取状态
    public ShareState getState(String key)
    &#123;
        ShareState s=(ShareState)stateSet.get(key);
        return s;
    &#125;
    //对请求做处理
    public void Handle()
    &#123;
        state.Handle(this);
    &#125;
&#125;
//抽象状态类
abstract class ShareState
&#123;
    public abstract void Handle(ShareContext context);
&#125;
//具体状态1类
class ConcreteState1 extends ShareState
&#123;
    public void Handle(ShareContext context)
    &#123;
        System.out.println(&quot;当前状态是： 状态1&quot;);
        context.setState(context.getState(&quot;2&quot;));
    &#125;
&#125;
//具体状态2类
class ConcreteState2 extends ShareState
&#123;
    public void Handle(ShareContext context)
    &#123;
        System.out.println(&quot;当前状态是： 状态2&quot;);
        context.setState(context.getState(&quot;1&quot;));
    &#125;
&#125;

当前状态是： 状态1
当前状态是： 状态2
当前状态是： 状态1
当前状态是： 状态2</code></pre>
<h3 id="6-观察者（Observer）模式"><a href="#6-观察者（Observer）模式" class="headerlink" title="6.观察者（Observer）模式"></a>6.观察者（Observer）模式</h3><p>在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。例如，某种商品的物价上涨时会导致部分商家高兴，而消费者伤心；还有，当我们开车到交叉路口时，遇到红灯会停，遇到绿灯会行。这样的例子还有很多，例如，股票价格与股民、微信公众号与微信用户、气象局的天气预报与听众、小偷与警察等。</p>
<p>在软件世界也是这样，例如，Excel 中的数据与折线图、饼状图、柱状图之间的关系；MVC 模式中的模型与视图的关系；事件模型中的事件源与事件处理者。所有这些，如果用观察者模式来实现就非常方便。 </p>
<h4 id="模式的定义与特点-6"><a href="#模式的定义与特点-6" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h4><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。 </p>
<p>观察者模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li>
<li>目标与观察者之间建立了一套触发机制。</li>
</ol>
<p>它的主要缺点如下。</p>
<ol>
<li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li>
<li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li>
</ol>
<h4 id="模式的结构与实现-6"><a href="#模式的结构与实现-6" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><p>实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用，否则将使两者之间紧密耦合起来，这违反了面向对象的设计原则。 </p>
<h5 id="1-模式的结构-15"><a href="#1-模式的结构-15" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li>
<li>具体主题（Concrete  Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li>
<li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li>
<li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-15"><a href="#2-模式的实现-15" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package observer;
import java.util.*;
public class ObserverPattern
&#123;
    public static void main(String[] args)
    &#123;
        Subject subject=new ConcreteSubject();
        Observer obs1=new ConcreteObserver1();
        Observer obs2=new ConcreteObserver2();
        subject.add(obs1);
        subject.add(obs2);
        subject.notifyObserver();
    &#125;
&#125;
//抽象目标
abstract class Subject
&#123;
    protected List&lt;Observer&gt; observers=new ArrayList&lt;Observer&gt;();   
    //增加观察者方法
    public void add(Observer observer)
    &#123;
        observers.add(observer);
    &#125;    
    //删除观察者方法
    public void remove(Observer observer)
    &#123;
        observers.remove(observer);
    &#125;   
    public abstract void notifyObserver(); //通知观察者方法
&#125;
//具体目标
class ConcreteSubject extends Subject
&#123;
    public void notifyObserver()
    &#123;
        System.out.println(&quot;具体目标发生改变...&quot;);
        System.out.println(&quot;--------------&quot;);       

        for(Object obs:observers)
        &#123;
            ((Observer)obs).response();
        &#125;

    &#125;          
&#125;
//抽象观察者
interface Observer
&#123;
    void response(); //反应
&#125;
//具体观察者1
class ConcreteObserver1 implements Observer
&#123;
    public void response()
    &#123;
        System.out.println(&quot;具体观察者1作出反应！&quot;);
    &#125;
&#125;
//具体观察者1
class ConcreteObserver2 implements Observer
&#123;
    public void response()
    &#123;
        System.out.println(&quot;具体观察者2作出反应！&quot;);
    &#125;
&#125;

具体目标发生改变...
--------------
具体观察者1作出反应！
具体观察者2作出反应！</code></pre>
<h4 id="模式的应用实例-5"><a href="#模式的应用实例-5" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h4><p><strong>利用观察者模式设计一个程序，分析“人民币汇率”的升值或贬值对进口公司的进口产品成本或出口公司的出口产品收入以及公司的利润率的影响</strong> </p>
<p>当“人民币汇率”升值时，进口公司的进口产品成本降低且利润率提升，出口公司的出口产品收入降低且利润率降低；当“人民币汇率”贬值时，进口公司的进口产品成本提升且利润率降低，出口公司的出口产品收入提升且利润率提升。 </p>
<p>这里的汇率（Rate）类是抽象目标类，它包含了保存观察者（Company）的 List 和增加/删除观察者的方法，以及有关汇率改变的抽象方法 change(int number)；而人民币汇率（RMBrate）类是具体目标， 它实现了父类的 change(int number) 方法，即当人民币汇率发生改变时通过相关公司；公司（Company）类是抽象观察者，它定义了一个有关汇率反应的抽象方法 response(int number)；进口公司（ImportCompany）类和出口公司（ExportCompany）类是具体观察者类，它们实现了父类的 response(int number) 方法，即当它们接收到汇率发生改变的通知时作为相应的反应。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E4%BA%BA%E6%B0%91%E5%B8%81%E6%B1%87%E7%8E%87%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package observer;
import java.util.*;
public class RMBrateTest
&#123;
    public static void main(String[] args)
    &#123;
        Rate rate=new RMBrate();         
        Company watcher1=new ImportCompany(); 
        Company watcher2=new ExportCompany();           
        rate.add(watcher1); 
        rate.add(watcher2);           
        rate.change(10);
        rate.change(-9);
    &#125;
&#125;
//抽象目标：汇率
abstract class Rate
&#123;
    protected List&lt;Company&gt; companys=new ArrayList&lt;Company&gt;();   
    //增加观察者方法
    public void add(Company company)
    &#123;
        companys.add(company);
    &#125;    
    //删除观察者方法
    public void remove(Company company)
    &#123;
        companys.remove(company);
    &#125;   
    public abstract void change(int number);
&#125;
//具体目标：人民币汇率
class RMBrate extends Rate 
&#123;
    public void change(int number)
    &#123;       
        for(Company obs:companys)
        &#123;
            ((Company)obs).response(number);
        &#125;       
    &#125;

&#125;
//抽象观察者：公司
interface Company
&#123;
    void response(int number);
&#125;
//具体观察者1：进口公司 
class ImportCompany implements Company 
&#123;
    public void response(int number) 
    &#123;
        if(number&gt;0)
        &#123;
            System.out.println(&quot;人民币汇率升值&quot;+number+&quot;个基点，降低了进口产品成本，提升了进口公司利润率。&quot;); 
        &#125;
        else if(number&lt;0)
        &#123;
              System.out.println(&quot;人民币汇率贬值&quot;+(-number)+&quot;个基点，提升了进口产品成本，降低了进口公司利润率。&quot;); 
        &#125;
    &#125; 
&#125; 
//具体观察者2：出口公司
class ExportCompany implements Company 
&#123;
    public void response(int number) 
    &#123;
        if(number&gt;0)
        &#123;
            System.out.println(&quot;人民币汇率升值&quot;+number+&quot;个基点，降低了出口产品收入，降低了出口公司的销售利润率。&quot;); 
        &#125;
        else if(number&lt;0)
        &#123;
              System.out.println(&quot;人民币汇率贬值&quot;+(-number)+&quot;个基点，提升了出口产品收入，提升了出口公司的销售利润率。&quot;); 
        &#125;
    &#125; 
&#125;

人民币汇率升值10个基点，降低了进口产品成本，提升了进口公司利润率。
人民币汇率升值10个基点，降低了出口产品收入，降低了出口公司的销售利润率。
人民币汇率贬值9个基点，提升了进口产品成本，降低了进口公司利润率。
人民币汇率贬值9个基点，提升了出口产品收入，提升了出口公司的销售利润率。</code></pre>
<blockquote>
<p>观察者模式在软件幵发中用得最多的是窗体程序设计中的事件处理，窗体中的所有组件都是“事件源”，也就是目标对象，而事件处理程序类的对象是具体观察者对象。下面以一个学校铃声的事件处理程序为例，介绍 Windows 中的“事件处理模型”的工作原理。 </p>
</blockquote>
<p><strong>利用观察者模式设计一个学校铃声的事件处理程序</strong> </p>
<p>在本实例中，学校的“铃”是事件源和目标，“老师”和“学生”是事件监听器和具体观察者，“铃声”是事件类。学生和老师来到学校的教学区，都会注意学校的铃，这叫事件绑定；当上课时间或下课时间到，会触发铃发声，这时会生成“铃声”事件；学生和老师听到铃声会开始上课或下课，这叫事件处理。这个实例非常适合用观察者模式实现。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AD%A6%E6%A0%A1%E9%93%83%E5%A3%B0%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%9B%BE.gif"></p>
<p>现在用“观察者模式”来实现该事件处理模型。首先，定义一个铃声事件（RingEvent）类，它记录了铃声的类型（上课铃声/下课铃声）；再定义一个学校的铃（BellEventSource）类，它是事件源，是观察者目标类，该类里面包含了监听器容器 listener，可以绑定监听者（学生或老师），并且有产生铃声事件和通知所有监听者的方法；然后，定义一声事件监听者（BellEventListener）类，它是抽象观察者，它包含了铃声事件处理方法 heardBell(RingEvent e)；最后，定义老师类（TeachEventListener）和学生类（StuEventListener），它们是事件监听器，是具体观察者，听到铃声会去上课或下课。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%AD%A6%E6%A0%A1%E9%93%83%E5%A3%B0%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package observer;
import java.util.*;
public class BellEventTest
&#123;
    public static void main(String[] args)
    &#123;
        BellEventSource bell=new BellEventSource();    //铃（事件源）    
        bell.addPersonListener(new TeachEventListener()); //注册监听器（老师）
        bell.addPersonListener(new StuEventListener());    //注册监听器（学生）
        bell.ring(true);   //打上课铃声
        System.out.println(&quot;------------&quot;);   
        bell.ring(false);  //打下课铃声
    &#125;
&#125;
//铃声事件类：用于封装事件源及一些与事件相关的参数
class RingEvent extends EventObject
&#123;   
    private static final long serialVersionUID=1L;
    private boolean sound;    //true表示上课铃声,false表示下课铃声
    public RingEvent(Object source,boolean sound)
    &#123;
        super(source);
        this.sound=sound;
    &#125;   
    public void setSound(boolean sound)
    &#123;
        this.sound=sound;
    &#125;
    public boolean getSound()
    &#123;
        return this.sound;
    &#125;
&#125;
//目标类：事件源，铃
class BellEventSource
&#123;    
    private List&lt;BellEventListener&gt; listener; //监听器容器
    public BellEventSource()
    &#123; 
        listener=new ArrayList&lt;BellEventListener&gt;();        
    &#125;
    //给事件源绑定监听器 
    public void addPersonListener(BellEventListener ren)
    &#123; 
        listener.add(ren); 
    &#125;
    //事件触发器：敲钟，当铃声sound的值发生变化时，触发事件。
    public void ring(boolean sound)
    &#123;
        String type=sound?&quot;上课铃&quot;:&quot;下课铃&quot;;
        System.out.println(type+&quot;响！&quot;);
        RingEvent event=new RingEvent(this, sound);     
        notifies(event);    //通知注册在该事件源上的所有监听器                
    &#125;   
    //当事件发生时,通知绑定在该事件源上的所有监听器做出反应（调用事件处理方法）
    protected void notifies(RingEvent e)
    &#123; 
        BellEventListener ren=null; 
        Iterator&lt;BellEventListener&gt; iterator=listener.iterator(); 
        while(iterator.hasNext())
        &#123; 
            ren=iterator.next(); 
            ren.heardBell(e); 
        &#125; 
    &#125;
&#125;
//抽象观察者类：铃声事件监听器
interface  BellEventListener extends EventListener
&#123;
    //事件处理方法，听到铃声
    public void heardBell(RingEvent e);
&#125;
//具体观察者类：老师事件监听器
class TeachEventListener implements BellEventListener
&#123;
    public void heardBell(RingEvent e)
    &#123;        
        if(e.getSound())
        &#123;
            System.out.println(&quot;老师上课了...&quot;);           
        &#125;
        else
        &#123;
            System.out.println(&quot;老师下课了...&quot;);   
        &#125;          
    &#125;
&#125;
//具体观察者类：学生事件监听器
class StuEventListener implements BellEventListener
&#123;
    public void heardBell(RingEvent e)
    &#123;        
        if(e.getSound())
        &#123;
            System.out.println(&quot;同学们，上课了...&quot;);           
        &#125;
        else
        &#123;
            System.out.println(&quot;同学们，下课了...&quot;);   
        &#125;          
    &#125;
&#125;

上课铃响！
老师上课了...
同学们，上课了...
------------
下课铃响！
老师下课了...
同学们，下课了...</code></pre>
<h4 id="模式的应用场景-5"><a href="#模式的应用场景-5" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h4><ol>
<li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li>
</ol>
<h4 id="模式的扩展-5"><a href="#模式的扩展-5" class="headerlink" title="模式的扩展"></a>模式的扩展</h4><p>在Java中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。 </p>
<h6 id="1-Observable类"><a href="#1-Observable类" class="headerlink" title="1. Observable类"></a>1. Observable类</h6><p>Observable 类是抽象目标类，它有一个 Vector 向量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。</p>
<ol>
<li>void addObserver(Observer o) 方法：用于将新的观察者对象添加到向量中。</li>
<li>void notifyObservers(Object arg) 方法：调用向量中的所有观察者对象的 update。方法，通知它们数据发生改变。通常越晚加入向量的观察者越先得到通知。</li>
<li>void setChange() 方法：用来设置一个 boolean 类型的内部标志位，注明目标对象发生了变化。当它为真时，notifyObservers() 才会通知观察者。</li>
</ol>
<h6 id="2-Observer-接口"><a href="#2-Observer-接口" class="headerlink" title="2. Observer 接口"></a>2. Observer 接口</h6><p>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 void update(Observable o,Object arg) 方法，进行相应的工作。</p>
<p><strong>利用 Observable 类和 Observer 接口实现原油期货的观察者模式实例</strong> </p>
<p>当原油价格上涨时，空方伤心，多方局兴；当油价下跌时，空方局兴，多方伤心。本实例中的抽象目标（Observable)类在 Java 中已经定义，可以直接定义其子类，即原油期货（OilFutures)类，它是具体目标类，该类中定义一个 SetPriCe(float price) 方法，当原油数据发生变化时调用其父类的 notifyObservers(Object arg) 方法来通知所有观察者；另外，本实例中的抽象观察者接口（Observer）在 Java 中已经定义，只要定义其子类，即具体观察者类（包括多方类 Bull 和空方类 Bear），并实现 update(Observable o,Object arg) 方法即可。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8E%9F%E6%B2%B9%E6%9C%9F%E8%B4%A7%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package observer;
import java.util.Observer;
import java.util.Observable;
public class CrudeOilFutures
&#123;
    public static void main(String[] args)
    &#123;
        OilFutures oil=new OilFutures();
        Observer bull=new Bull(); //多方
        Observer bear=new Bear(); //空方
        oil.addObserver(bull);
        oil.addObserver(bear);
        oil.setPrice(10);
        oil.setPrice(-8);
    &#125;
&#125;
//具体目标类：原油期货
class OilFutures extends Observable
&#123;
    private float price;   
    public float getPrice()
    &#123;
        return this.price; 
    &#125;
    public void setPrice(float price)
    &#123;
        super.setChanged() ;  //设置内部标志位，注明数据发生变化 
        super.notifyObservers(price);    //通知观察者价格改变了 
        this.price=price ; 
    &#125;
&#125;
//具体观察者类：多方
class Bull implements Observer
&#123;   
    public void update(Observable o,Object arg)
    &#123;
        Float price=((Float)arg).floatValue();
        if(price&gt;0)
        &#123;
            System.out.println(&quot;油价上涨&quot;+price+&quot;元，多方高兴了！&quot;);
        &#125;
        else
        &#123;
            System.out.println(&quot;油价下跌&quot;+(-price)+&quot;元，多方伤心了！&quot;);
        &#125;
    &#125;
&#125;
//具体观察者类：空方
class Bear implements Observer
&#123;   
    public void update(Observable o,Object arg)
    &#123;
        Float price=((Float)arg).floatValue();
        if(price&gt;0)
        &#123;
            System.out.println(&quot;油价上涨&quot;+price+&quot;元，空方伤心了！&quot;);
        &#125;
        else
        &#123;
            System.out.println(&quot;油价下跌&quot;+(-price)+&quot;元，空方高兴了！&quot;);
        &#125;
    &#125;
&#125;

油价上涨10.0元，空方伤心了！
油价上涨10.0元，多方高兴了！
油价下跌8.0元，空方高兴了！
油价下跌8.0元，多方伤心了！</code></pre>
<h3 id="7-中介者（Mediator）模式"><a href="#7-中介者（Mediator）模式" class="headerlink" title="7.中介者（Mediator）模式"></a>7.中介者（Mediator）模式</h3><p>在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是“网状结构”，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他（她）所有朋友的电话；而且，朋友中如果有人的电话修改了，他（她）必须告诉其他所有的朋友修改，这叫作“牵一发而动全身”，非常复杂。 </p>
<p>如果把这种“网状结构”改为“星形结构”的话，将大大降低它们之间的“耦合性”，这时只要找一个“中介者”就可以了。如前面所说的“每个人必须记住所有朋友电话”的问题，只要在网上建立一个每个朋友都可以访问的“通信录”就解决了。这样的例子还有很多，例如，你刚刚参力口工作想租房，可以找“房屋中介”；或者，自己刚刚到一个陌生城市找工作，可以找“人才交流中心”帮忙。</p>
<p>在软件的开发过程中，这样的例子也很多，例如，在 MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；还有大家常用的 QQ 聊天程序的“中介者”是 QQ 服务器。所有这些，都可以采用“中介者模式”来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。 </p>
<h4 id="模式的定义与特点-7"><a href="#模式的定义与特点-7" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h4><p>中介者（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。 </p>
<p>中介者模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>降低了对象之间的耦合性，使得对象易于独立地被复用。</li>
<li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li>
</ol>
<p>其主要缺点是：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。 </p>
<h5 id="1-模式的结构-16"><a href="#1-模式的结构-16" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li>
<li>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li>
<li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li>
<li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-16"><a href="#2-模式的实现-16" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package mediator;
import java.util.*;
public class MediatorPattern
&#123;
    public static void main(String[] args)
    &#123;
        Mediator md=new ConcreteMediator();
        Colleague c1,c2;
        c1=new ConcreteColleague1();
        c2=new ConcreteColleague2();
        md.register(c1);
        md.register(c2);
        c1.send();
        System.out.println(&quot;-------------&quot;);
        c2.send();
    &#125;
&#125;
//抽象中介者
abstract class Mediator
&#123;
    public abstract void register(Colleague colleague);
    public abstract void relay(Colleague cl); //转发
&#125;
//具体中介者
class ConcreteMediator extends Mediator
&#123;
    private List&lt;Colleague&gt; colleagues=new ArrayList&lt;Colleague&gt;();
    public void register(Colleague colleague)
    &#123;
        if(!colleagues.contains(colleague))
        &#123;
            colleagues.add(colleague);
            colleague.setMedium(this);
        &#125;
    &#125;
    public void relay(Colleague cl)
    &#123;
        for(Colleague ob:colleagues)
        &#123;
            if(!ob.equals(cl))
            &#123;
                ((Colleague)ob).receive();
            &#125;   
        &#125;
    &#125;
&#125;
//抽象同事类
abstract class Colleague
&#123;
    protected Mediator mediator;
    public void setMedium(Mediator mediator)
    &#123;
        this.mediator=mediator;
    &#125;   
    public abstract void receive();   
    public abstract void send();
&#125;
//具体同事类
class ConcreteColleague1 extends Colleague
&#123;
    public void receive()
    &#123;
        System.out.println(&quot;具体同事类1收到请求。&quot;);
    &#125;   
    public void send()
    &#123;
        System.out.println(&quot;具体同事类1发出请求。&quot;);
        mediator.relay(this); //请中介者转发
    &#125;
&#125;
//具体同事类
class ConcreteColleague2 extends Colleague
&#123;
    public void receive()
    &#123;
        System.out.println(&quot;具体同事类2收到请求。&quot;);
    &#125;   
    public void send()
    &#123;
        System.out.println(&quot;具体同事类2发出请求。&quot;);
        mediator.relay(this); //请中介者转发
    &#125;
&#125;

具体同事类1发出请求。
具体同事类2收到请求。
-------------
具体同事类2发出请求。
具体同事类1收到请求。</code></pre>
<h4 id="模式的应用实例-6"><a href="#模式的应用实例-6" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h4><p><strong>用中介者模式编写一个“韶关房地产交流平台”程序</strong> </p>
<p>韶关房地产交流平台是“房地产中介公司”提供给“卖方客户”与“买方客户”进行信息交流的平台，比较适合用中介者模式来实现。 </p>
<p>首先，定义一个中介公司（Medium）接口，它是抽象中介者，它包含了客户注册方法 register(Customer member) 和信息转发方法 relay(String from,String ad)；再定义一个韶关房地产中介（EstateMedium）公司，它是具体中介者类，它包含了保存客户信息的 List 对象，并实现了中介公司中的抽象方法。</p>
<p>然后，定义一个客户（Qistomer）类，它是抽象同事类，其中包含了中介者的对象，和发送信息的 send(String ad) 方法与接收信息的 receive(String from，Stringad) 方法的接口，由于本程序是窗体程序，所以本类继承 JPmme 类，并实现动作事件的处理方法 actionPerformed(ActionEvent e)。</p>
<p>最后，定义卖方（Seller）类和买方（Buyer）类，它们是具体同事类，是客户（Customer）类的子类，它们实现了父类中的抽象方法，通过中介者类进行信息交流。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E9%9F%B6%E5%85%B3%E6%88%BF%E5%9C%B0%E4%BA%A7%E4%BA%A4%E6%B5%81%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package mediator;
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
public class DatingPlatform
&#123;
    public static void main(String[] args)
    &#123;
        Medium md=new EstateMedium();    //房产中介
        Customer member1,member2;
        member1=new Seller(&quot;张三(卖方)&quot;);
        member2=new Buyer(&quot;李四(买方)&quot;);
        md.register(member1); //客户注册
        md.register(member2);
    &#125;
&#125;
//抽象中介者：中介公司
interface Medium
&#123;
    void register(Customer member); //客户注册
    void relay(String from,String ad); //转发
&#125;
//具体中介者：房地产中介
class EstateMedium implements Medium
&#123;
    private List&lt;Customer&gt; members=new ArrayList&lt;Customer&gt;();   
    public void register(Customer member)
    &#123;
        if(!members.contains(member))
        &#123;
            members.add(member);
            member.setMedium(this);
        &#125;
    &#125;   
    public void relay(String from,String ad)
    &#123;
        for(Customer ob:members)
        &#123;
            String name=ob.getName();
            if(!name.equals(from))
            &#123;
                ((Customer)ob).receive(from,ad);
            &#125;   
        &#125;
    &#125;
&#125;
//抽象同事类：客户
abstract class Customer extends JFrame implements  ActionListener
&#123;
    private static final long serialVersionUID=-7219939540794786080L;
    protected Medium medium;
    protected String name;   
    JTextField SentText;
    JTextArea ReceiveArea;   
    public Customer(String name)
    &#123;
        super(name);
        this.name=name;       
    &#125;
    void ClientWindow(int x,int y)
    &#123;       
        Container cp;        
        JScrollPane sp;
        JPanel p1,p2;        
        cp=this.getContentPane();       
        SentText=new JTextField(18);
        ReceiveArea=new JTextArea(10,18);
        ReceiveArea.setEditable(false);
        p1=new JPanel();
        p1.setBorder(BorderFactory.createTitledBorder(&quot;接收内容：&quot;));       
        p1.add(ReceiveArea);
        sp=new JScrollPane(p1);
        cp.add(sp,BorderLayout.NORTH);        
        p2=new JPanel();
        p2.setBorder(BorderFactory.createTitledBorder(&quot;发送内容：&quot;));       
        p2.add(SentText);   
        cp.add(p2,BorderLayout.SOUTH);       
        SentText.addActionListener(this);       
        this.setLocation(x,y);
        this.setSize(250, 330);
        this.setResizable(false); //窗口大小不可调整
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);      
        this.setVisible(true);       
    &#125;
    public void actionPerformed(ActionEvent e)
    &#123;
        String tempInfo=SentText.getText().trim();
        SentText.setText(&quot;&quot;);
        this.send(tempInfo);
    &#125;
    public String getName()
    &#123;    return name;   &#125;
    public void setMedium(Medium medium)
    &#123;      this.medium=medium;  &#125;   
    public abstract void send(String ad);
    public abstract void receive(String from,String ad);
&#125;
//具体同事类：卖方
class Seller extends Customer
&#123;
    private static final long serialVersionUID=-1443076716629516027L;
    public Seller(String name)
    &#123;
        super(name);
        ClientWindow(50,100);
    &#125;   
    public void send(String ad)
    &#123;
        ReceiveArea.append(&quot;我(卖方)说: &quot;+ad+&quot;\n&quot;);
        //使滚动条滚动到最底端
        ReceiveArea.setCaretPosition(ReceiveArea.getText().length());
        medium.relay(name,ad);
    &#125;
    public void receive(String from,String ad)
    &#123;
        ReceiveArea.append(from +&quot;说: &quot;+ad+&quot;\n&quot;);
        //使滚动条滚动到最底端
        ReceiveArea.setCaretPosition(ReceiveArea.getText().length());
    &#125;
&#125;
//具体同事类：买方
class Buyer extends Customer
&#123;
    private static final long serialVersionUID = -474879276076308825L;
    public Buyer(String name)
    &#123;
        super(name);
        ClientWindow(350,100);
    &#125;   
    public void send(String ad)
    &#123;
        ReceiveArea.append(&quot;我(买方)说: &quot;+ad+&quot;\n&quot;);
        //使滚动条滚动到最底端
        ReceiveArea.setCaretPosition(ReceiveArea.getText().length());
        medium.relay(name,ad);
    &#125;
    public void receive(String from,String ad)
    &#123;
          ReceiveArea.append(from +&quot;说: &quot;+ad+&quot;\n&quot;);
        //使滚动条滚动到最底端
        ReceiveArea.setCaretPosition(ReceiveArea.getText().length());
    &#125;
&#125;

</code></pre>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E9%9F%B6%E5%85%B3%E6%88%BF%E5%9C%B0%E4%BA%A7%E4%BA%A4%E6%B5%81%E5%B9%B3%E5%8F%B0%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.gif"></p>
<h4 id="模式的应用场景-6"><a href="#模式的应用场景-6" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h4><ul>
<li>当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。</li>
<li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li>
</ul>
<h4 id="模式的扩展-6"><a href="#模式的扩展-6" class="headerlink" title="模式的扩展"></a>模式的扩展</h4><p>在实际开发中，通常采用以下两种方法来简化中介者模式，使开发变得更简单。</p>
<ol>
<li>不定义中介者接口，把具体中介者对象实现成为单例。</li>
<li>同事对象不持有中介者，而是在需要的时f矣直接获取中介者对象并调用。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%AE%80%E5%8C%96%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package mediator;
import java.util.*;
public class SimpleMediatorPattern
&#123;
    public static void main(String[] args)
    &#123;
        SimpleColleague c1,c2;
        c1=new SimpleConcreteColleague1();
        c2=new SimpleConcreteColleague2();
        c1.send();
        System.out.println(&quot;-----------------&quot;);
        c2.send();
    &#125;
&#125;
//简单单例中介者
class SimpleMediator
&#123;
    private static SimpleMediator smd=new SimpleMediator();   
    private List&lt;SimpleColleague&gt; colleagues=new ArrayList&lt;SimpleColleague&gt;();   
    private SimpleMediator()&#123;&#125;   
    public static SimpleMediator getMedium()
    &#123;    return(smd);   &#125;
    public void register(SimpleColleague colleague)
    &#123;
        if(!colleagues.contains(colleague))
        &#123;
            colleagues.add(colleague);
        &#125;
    &#125;
    public void relay(SimpleColleague scl)
    &#123;       
        for(SimpleColleague ob:colleagues)
        &#123;
            if(!ob.equals(scl))
            &#123;
                ((SimpleColleague)ob).receive();
            &#125;   
        &#125;
    &#125;
&#125;
//抽象同事类
interface SimpleColleague
&#123;
    void receive();   
    void send();
&#125;
//具体同事类
class SimpleConcreteColleague1 implements SimpleColleague
&#123;
    SimpleConcreteColleague1()&#123;
        SimpleMediator smd=SimpleMediator.getMedium();
        smd.register(this);
    &#125;
    public void receive()
    &#123;    System.out.println(&quot;具体同事类1：收到请求。&quot;);    &#125;   
    public void send()
    &#123;
        SimpleMediator smd=SimpleMediator.getMedium();
        System.out.println(&quot;具体同事类1：发出请求...&quot;);
        smd.relay(this); //请中介者转发
    &#125;
&#125;
//具体同事类
class SimpleConcreteColleague2 implements SimpleColleague
&#123;
    SimpleConcreteColleague2()&#123;
        SimpleMediator smd=SimpleMediator.getMedium();
        smd.register(this);
    &#125;
    public void receive()
    &#123;    System.out.println(&quot;具体同事类2：收到请求。&quot;);    &#125;   
    public void send()
    &#123;
        SimpleMediator smd=SimpleMediator.getMedium();
        System.out.println(&quot;具体同事类2：发出请求...&quot;);
        smd.relay(this); //请中介者转发
    &#125;
&#125;

具体同事类1：发出请求...
具体同事类2：收到请求。
-----------------
具体同事类2：发出请求...
具体同事类1：收到请求。</code></pre>
<h3 id="8-迭代器（Iterator）模式"><a href="#8-迭代器（Iterator）模式" class="headerlink" title="8.迭代器（Iterator）模式"></a>8.迭代器（Iterator）模式</h3><p>在现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，如“数据结构”中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。 </p>
<p>既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：</p>
<ol>
<li>暴露了聚合类的内部表示，使其数据不安全；</li>
<li>增加了客户的负担。</li>
</ol>
<p>“迭代器模式”能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”，如 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 中的 Collection、List、Set、Map 等都包含了迭代器。 </p>
<h4 id="模式的定义与特点-8"><a href="#模式的定义与特点-8" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h4><p>迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。</li>
<li>遍历任务交由迭代器完成，这简化了聚合类。</li>
<li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li>
<li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li>
<li>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li>
</ol>
<p>其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。 </p>
<h4 id="模式的结构与实现-7"><a href="#模式的结构与实现-7" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><p>迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。 </p>
<h5 id="1-模式的结构-17"><a href="#1-模式的结构-17" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li>
<li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li>
<li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。</li>
<li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-17"><a href="#2-模式的实现-17" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package iterator;
import java.util.*;
public class IteratorPattern
&#123;
    public static void main(String[] args)
    &#123;
        Aggregate ag=new ConcreteAggregate(); 
        ag.add(&quot;中山大学&quot;); 
        ag.add(&quot;华南理工&quot;); 
        ag.add(&quot;韶关学院&quot;);
        System.out.print(&quot;聚合的内容有：&quot;);
        Iterator it=ag.getIterator(); 
        while(it.hasNext())
        &#123; 
            Object ob=it.next(); 
            System.out.print(ob.toString()+&quot;\t&quot;); 
        &#125;
        Object ob=it.first();
        System.out.println(&quot;\nFirst：&quot;+ob.toString());
    &#125;
&#125;
//抽象聚合
interface Aggregate
&#123; 
    public void add(Object obj); 
    public void remove(Object obj); 
    public Iterator getIterator(); 
&#125;
//具体聚合
class ConcreteAggregate implements Aggregate
&#123; 
    private List&lt;Object&gt; list=new ArrayList&lt;Object&gt;(); 
    public void add(Object obj)
    &#123; 
        list.add(obj); 
    &#125;
    public void remove(Object obj)
    &#123; 
        list.remove(obj); 
    &#125;
    public Iterator getIterator()
    &#123; 
        return(new ConcreteIterator(list)); 
    &#125;     
&#125;
//抽象迭代器
interface Iterator
&#123;
    Object first();
    Object next();
    boolean hasNext();
&#125;
//具体迭代器
class ConcreteIterator implements Iterator
&#123; 
    private List&lt;Object&gt; list=null; 
    private int index=-1; 
    public ConcreteIterator(List&lt;Object&gt; list)
    &#123; 
        this.list=list; 
    &#125; 
    public boolean hasNext()
    &#123; 
        if(index&lt;list.size()-1)
        &#123; 
            return true;
        &#125;
        else
        &#123;
            return false;
        &#125;
    &#125;
    public Object first()
    &#123;
        index=0;
        Object obj=list.get(index);;
        return obj;
    &#125;
    public Object next()
    &#123; 
        Object obj=null; 
        if(this.hasNext())
        &#123; 
            obj=list.get(++index); 
        &#125; 
        return obj; 
    &#125;   
&#125;

聚合的内容有：中山大学    华南理工    韶关学院   
First：中山大学</code></pre>
<h4 id="模式的应用实例-7"><a href="#模式的应用实例-7" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h4><p><strong>用迭代器模式编写一个浏览婺源旅游风景图的程序</strong> </p>
<p>婺源的名胜古迹较多，要设计一个查看相关景点图片和简介的程序，用“迭代器模式”设计比较合适。 </p>
<p>首先，设计一个婺源景点（WyViewSpot）类来保存每张图片的名称与简介；再设计一个景点集（ViewSpotSet）接口，它是抽象聚合类，提供了增加和删除婺源景点的方法，以及获取迭代器的方法。</p>
<p>然后，定义一个婺源景点集（WyViewSpotSet）类，它是具体聚合类，用 ArrayList 来保存所有景点信息，并实现父类中的抽象方法；再定义婺源景点的抽象迭代器（ViewSpotltemtor）接口，其中包含了查看景点信息的相关方法。</p>
<p>最后，定义婺源景点的具体迭代器（WyViewSpotlterator）类，它实现了父类的抽象方法；客户端程序设计成窗口程序，它初始化婺源景点集（ViewSpotSet）中的数据，并实现 ActionListener 接口，它通过婺源景点迭代器（ViewSpotlterator）来査看婺源景点（WyViewSpot）的信息。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A9%BA%E6%BA%90%E6%97%85%E6%B8%B8%E9%A3%8E%E6%99%AF%E5%9B%BE%E6%B5%8F%E8%A7%88%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package iterator;
import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import javax.swing.*;
public class PictureIterator&#123;
    public static void main(String[] args)
    &#123;
        new PictureFrame();
    &#125;
&#125;
//相框类
class PictureFrame extends JFrame implements ActionListener
&#123;
    private static final long serialVersionUID=1L;
    ViewSpotSet ag; //婺源景点集接口
    ViewSpotIterator it; //婺源景点迭代器接口
    WyViewSpot ob;    //婺源景点类
    PictureFrame()
    &#123;
        super(&quot;中国最美乡村“婺源”的部分风景图&quot;);
        this.setResizable(false);
        ag=new WyViewSpotSet(); 
        ag.add(new WyViewSpot(&quot;江湾&quot;,&quot;江湾景区是婺源的一个国家5A级旅游景区，景区内有萧江宗祠、永思街、滕家老屋、婺源人家、乡贤园、百工坊等一大批古建筑，精美绝伦，做工精细。&quot;)); 
        ag.add(new WyViewSpot(&quot;李坑&quot;,&quot;李坑村是一个以李姓聚居为主的古村落，是国家4A级旅游景区，其建筑风格独特，是著名的徽派建筑，给人一种安静、祥和的感觉。&quot;)); 
        ag.add(new WyViewSpot(&quot;思溪延村&quot;,&quot;思溪延村位于婺源县思口镇境内，始建于南宋庆元五年（1199年），当时建村者俞氏以（鱼）思清溪水而名。&quot;));
        ag.add(new WyViewSpot(&quot;晓起村&quot;,&quot;晓起有“中国茶文化第一村”与“国家级生态示范村”之美誉，村屋多为清代建筑，风格各具特色，村中小巷均铺青石，曲曲折折，回环如棋局。&quot;)); 
        ag.add(new WyViewSpot(&quot;菊径村&quot;,&quot;菊径村形状为山环水绕型，小河成大半圆型，绕村庄将近一周，四周为高山环绕，符合中国的八卦“后山前水”设计，当地人称“脸盆村”。&quot;)); 
        ag.add(new WyViewSpot(&quot;篁岭&quot;,&quot;篁岭是著名的“晒秋”文化起源地，也是一座距今近六百历史的徽州古村；篁岭属典型山居村落，民居围绕水口呈扇形梯状错落排布。&quot;));
        ag.add(new WyViewSpot(&quot;彩虹桥&quot;,&quot;彩虹桥是婺源颇有特色的带顶的桥——廊桥，其不仅造型优美，而且它可在雨天里供行人歇脚，其名取自唐诗“两水夹明镜，双桥落彩虹”。&quot;)); 
        ag.add(new WyViewSpot(&quot;卧龙谷&quot;,&quot;卧龙谷是国家4A级旅游区，这里飞泉瀑流泄银吐玉、彩池幽潭碧绿清新、山峰岩石挺拔奇巧，活脱脱一幅天然泼墨山水画。&quot;));
        it = ag.getIterator(); //获取婺源景点迭代器 
        ob = it.first(); 
        this.showPicture(ob.getName(),ob.getIntroduce());
    &#125;
    //显示图片
    void showPicture(String Name,String Introduce)
    &#123;       
        Container cp=this.getContentPane();       
        JPanel picturePanel=new JPanel();
        JPanel controlPanel=new JPanel();       
        String FileName=&quot;src/iterator/Picture/&quot;+Name+&quot;.jpg&quot;;
        JLabel lb=new JLabel(Name,new ImageIcon(FileName),JLabel.CENTER);   
        JTextArea ta=new JTextArea(Introduce);       
        lb.setHorizontalTextPosition(JLabel.CENTER);
        lb.setVerticalTextPosition(JLabel.TOP);
        lb.setFont(new Font(&quot;宋体&quot;,Font.BOLD,20));
        ta.setLineWrap(true);       
        ta.setEditable(false);
        //ta.setBackground(Color.orange);
        picturePanel.setLayout(new BorderLayout(5,5));
        picturePanel.add(&quot;Center&quot;,lb);       
        picturePanel.add(&quot;South&quot;,ta);       
        JButton first, last, next, previous;
        first=new JButton(&quot;第一张&quot;);
        next=new JButton(&quot;下一张&quot;);
        previous=new JButton(&quot;上一张&quot;);
        last=new JButton(&quot;最末张&quot;);
        first.addActionListener(this);
        next.addActionListener(this);
        previous.addActionListener(this);
        last.addActionListener(this);        
        controlPanel.add(first);
        controlPanel.add(next);
        controlPanel.add(previous);
        controlPanel.add(last);       
        cp.add(&quot;Center&quot;,picturePanel);
        cp.add(&quot;South&quot;,controlPanel);
        this.setSize(630, 550);
        this.setVisible(true);
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    &#125;
    @Override
    public void actionPerformed(ActionEvent arg0)
    &#123;
        String command=arg0.getActionCommand();
        if(command.equals(&quot;第一张&quot;))
        &#123;
            ob=it.first(); 
            this.showPicture(ob.getName(),ob.getIntroduce());
        &#125;
        else if(command.equals(&quot;下一张&quot;))
        &#123;
            ob=it.next(); 
            this.showPicture(ob.getName(),ob.getIntroduce());
        &#125;
        else if(command.equals(&quot;上一张&quot;))
        &#123;
            ob=it.previous(); 
            this.showPicture(ob.getName(),ob.getIntroduce());
        &#125;
        else if(command.equals(&quot;最末张&quot;))
        &#123;
            ob=it.last(); 
            this.showPicture(ob.getName(),ob.getIntroduce());
        &#125;
    &#125;
&#125;
//婺源景点类
class WyViewSpot
&#123;
    private String Name;
    private String Introduce;
    WyViewSpot(String Name,String Introduce)
    &#123;
        this.Name=Name;
        this.Introduce=Introduce;
    &#125;
    public String getName()
    &#123;
        return Name;
    &#125;
    public String getIntroduce()
    &#123;
        return Introduce;
    &#125;
&#125;
//抽象聚合：婺源景点集接口
interface ViewSpotSet
&#123; 
    void add(WyViewSpot obj); 
    void remove(WyViewSpot obj); 
    ViewSpotIterator getIterator(); 
&#125;
//具体聚合：婺源景点集
class WyViewSpotSet implements ViewSpotSet
&#123; 
    private ArrayList&lt;WyViewSpot&gt; list=new ArrayList&lt;WyViewSpot&gt;(); 
    public void add(WyViewSpot obj)
    &#123; 
        list.add(obj); 
    &#125;
    public void remove(WyViewSpot obj)
    &#123; 
        list.remove(obj); 
    &#125;
    public ViewSpotIterator getIterator()
    &#123; 
        return(new WyViewSpotIterator(list)); 
    &#125;     
&#125;
//抽象迭代器：婺源景点迭代器接口
interface ViewSpotIterator
&#123;
    boolean hasNext();
    WyViewSpot first();
    WyViewSpot next();
    WyViewSpot previous();
    WyViewSpot last(); 
&#125;
//具体迭代器：婺源景点迭代器
class WyViewSpotIterator implements ViewSpotIterator
&#123; 
    private ArrayList&lt;WyViewSpot&gt; list=null; 
    private int index=-1;
    WyViewSpot obj=null;
    public WyViewSpotIterator(ArrayList&lt;WyViewSpot&gt; list)
    &#123;
        this.list=list; 
    &#125; 
    public boolean hasNext()
    &#123; 
        if(index&lt;list.size()-1)
        &#123; 
            return true;
        &#125;
        else
        &#123;
            return false;
        &#125;
    &#125;
    public WyViewSpot first()
    &#123;
        index=0;
        obj=list.get(index);
        return obj;
    &#125;
    public WyViewSpot next()
    &#123;         
        if(this.hasNext())
        &#123; 
            obj=list.get(++index);
        &#125; 
        return obj; 
    &#125;
    public WyViewSpot previous()
    &#123; 
        if(index&gt;0)
        &#123; 
            obj=list.get(--index); 
        &#125; 
        return obj; 
    &#125;
    public WyViewSpot last()
    &#123;
        index=list.size()-1;
        obj=list.get(index);
        return obj;
    &#125;
&#125;</code></pre>
<h4 id="模式的应用场景-7"><a href="#模式的应用场景-7" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h4><ol>
<li>当需要为聚合对象提供多种遍历方式时。</li>
<li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li>
<li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li>
</ol>
<blockquote>
<p>由于聚合与迭代器的关系非常密切，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。 </p>
</blockquote>
<h4 id="模式的扩展-7"><a href="#模式的扩展-7" class="headerlink" title="模式的扩展"></a>模式的扩展</h4><p>迭代器模式常常与组合模式结合起来使用，在对组合模式中的容器构件进行访问时，经常将迭代器潜藏在组合模式的容器构成类中。当然，也可以构造一个外部迭代器来对容器构件进行访问。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%BB%84%E5%90%88%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h3 id="9-访问者（Visitor）模式"><a href="#9-访问者（Visitor）模式" class="headerlink" title="9.访问者（Visitor）模式"></a>9.访问者（Visitor）模式</h3><p>在现实生活中，有些集合对象中存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。例如，公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药。</p>
<p>这样的例子还有很多，例如，电影或电视剧中的人物角色，不同的观众对他们的评价也不同；还有顾客在商场购物时放在“购物车”中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。</p>
<p>这些被处理的数据元素相对稳定而访问方式多种多样的数据结构，如果用“访问者模式”来处理比较方便。访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。 </p>
<h4 id="模式的定义与特点-9"><a href="#模式的定义与特点-9" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h4><p>访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。 </p>
<p>访问者（Visitor）模式是一种对象行为型模式，其主要优点如下。</p>
<ol>
<li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>
<li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li>
<li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li>
<li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li>
</ol>
<p>访问者（Visitor）模式的主要缺点如下。</p>
<ol>
<li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li>
<li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li>
<li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li>
</ol>
<h4 id="模式的结构与实现-8"><a href="#模式的结构与实现-8" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><p>访问者（Visitor）模式实现的关键是如何将作用于元素的操作分离出来封装成独立的类。</p>
<h5 id="1-模式的结构-18"><a href="#1-模式的结构-18" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</li>
<li>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</li>
<li>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</li>
<li>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</li>
<li>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E8%AE%BF%E9%97%AE%E8%80%85%EF%BC%88Visitor%EF%BC%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-18"><a href="#2-模式的实现-18" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package visitor;
import java.util.*;
public class VisitorPattern
&#123;
    public static void main(String[] args)
    &#123;
        ObjectStructure os=new ObjectStructure();
        os.add(new ConcreteElementA());
        os.add(new ConcreteElementB());
        Visitor visitor=new ConcreteVisitorA();
        os.accept(visitor);
        System.out.println(&quot;------------------------&quot;);
        visitor=new ConcreteVisitorB();
        os.accept(visitor);
    &#125;
&#125;
//抽象访问者
interface Visitor
&#123;
    void visit(ConcreteElementA element);
    void visit(ConcreteElementB element);
&#125;
//具体访问者A类
class ConcreteVisitorA implements Visitor
&#123;
    public void visit(ConcreteElementA element)
    &#123;
        System.out.println(&quot;具体访问者A访问--&gt;&quot;+element.operationA());
    &#125;
    public void visit(ConcreteElementB element)
    &#123;
        System.out.println(&quot;具体访问者A访问--&gt;&quot;+element.operationB());
    &#125;
&#125;
//具体访问者B类
class ConcreteVisitorB implements Visitor
&#123;
    public void visit(ConcreteElementA element)
    &#123;
        System.out.println(&quot;具体访问者B访问--&gt;&quot;+element.operationA());
    &#125;
    public void visit(ConcreteElementB element)
    &#123;
        System.out.println(&quot;具体访问者B访问--&gt;&quot;+element.operationB());
    &#125;
&#125;
//抽象元素类
interface Element
&#123;
    void accept(Visitor visitor);
&#125;
//具体元素A类
class ConcreteElementA implements Element
&#123;
    public void accept(Visitor visitor)
    &#123;
        visitor.visit(this);
    &#125;
    public String operationA()
    &#123;
        return &quot;具体元素A的操作。&quot;;
    &#125;
&#125;
//具体元素B类
class ConcreteElementB implements Element
&#123;
    public void accept(Visitor visitor)
    &#123;
        visitor.visit(this);
    &#125;
    public String operationB()
    &#123;
        return &quot;具体元素B的操作。&quot;;
    &#125;
&#125;
//对象结构角色
class ObjectStructure
&#123;   
    private List&lt;Element&gt; list=new ArrayList&lt;Element&gt;();   
    public void accept(Visitor visitor)
    &#123;
        Iterator&lt;Element&gt; i=list.iterator();
        while(i.hasNext())
        &#123;
            ((Element) i.next()).accept(visitor);
        &#125;      
    &#125;
    public void add(Element element)
    &#123;
        list.add(element);
    &#125;
    public void remove(Element element)
    &#123;
        list.remove(element);
    &#125;
&#125;

具体访问者A访问--&gt;具体元素A的操作。
具体访问者A访问--&gt;具体元素B的操作。
------------------------
具体访问者B访问--&gt;具体元素A的操作。
具体访问者B访问--&gt;具体元素B的操作。</code></pre>
<h4 id="模式的应用实例-8"><a href="#模式的应用实例-8" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h4><p><strong>利用“访问者（Visitor）模式”模拟艺术公司与造币公司的功能</strong> </p>
<p>艺术公司利用“铜”可以设计出铜像，利用“纸”可以画出图画；造币公司利用“铜”可以印出铜币，利用“纸”可以印出纸币。对“铜”和“纸”这两种元素，两个公司的处理方法不同，所以该实例用访问者模式来实现比较适合。</p>
<p>首先，定义一个公司（Company）接口，它是抽象访问者，提供了两个根据纸（Paper）或铜（Cuprum）这两种元素创建作品的方法；再定义艺术公司（ArtCompany）类和造币公司（Mint）类，它们是具体访问者，实现了父接口的方法；然后，定义一个材料（Material）接口，它是抽象元素，提供了 accept（Company visitor）方法来接受访问者（Company）对象访问；再定义纸（Paper）类和铜（Cuprum）类，它们是具体元素类，实现了父接口中的方法；最后，定义一个材料集（SetMaterial）类，它是对象结构角色，拥有保存所有元素的容器 List，并提供让访问者对象遍历容器中的所有元素的 accept（Company visitor）方法；客户类设计成窗体程序，它提供材料集（SetMaterial）对象供访问者（Company）对象访问，实现了 ItemListener 接口，处理用户的事件请求。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E8%89%BA%E6%9C%AF%E5%85%AC%E5%8F%B8%E4%B8%8E%E9%80%A0%E5%B8%81%E5%85%AC%E5%8F%B8%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package visitor;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
public class VisitorProducer
&#123;
    public static void main(String[] args)
    &#123;
        new MaterialWin();       
    &#125;
&#125;
//窗体类
class MaterialWin extends JFrame implements ItemListener
&#123;
    private static final long serialVersionUID=1L;   
    JPanel CenterJP;
    SetMaterial os;    //材料集对象
    Company visitor1,visitor2;    //访问者对象
    String[] select;
    MaterialWin()
    &#123;
        super(&quot;利用访问者模式设计艺术公司和造币公司&quot;);
        JRadioButton Art;
        JRadioButton mint;           
        os=new SetMaterial();     
        os.add(new Cuprum());
        os.add(new Paper());
        visitor1=new ArtCompany();//艺术公司
        visitor2=new Mint(); //造币公司      
        this.setBounds(10,10,750,350);            
        this.setResizable(false);       
        CenterJP=new JPanel();       
        this.add(&quot;Center&quot;,CenterJP);      
        JPanel SouthJP=new JPanel();
        JLabel yl=new JLabel(&quot;原材料有：铜和纸，请选择生产公司：&quot;);
        Art=new JRadioButton(&quot;艺术公司&quot;,true);
        mint=new JRadioButton(&quot;造币公司&quot;);
        Art.addItemListener(this);
        mint.addItemListener(this);       
        ButtonGroup group=new ButtonGroup();
        group.add(Art);
        group.add(mint);
        SouthJP.add(yl);
        SouthJP.add(Art);
        SouthJP.add(mint);
        this.add(&quot;South&quot;,SouthJP);       
        select=(os.accept(visitor1)).split(&quot; &quot;);    //获取产品名
        showPicture(select[0],select[1]);    //显示产品
    &#125;
    //显示图片
    void showPicture(String Cuprum,String paper)
    &#123;
        CenterJP.removeAll();    //清除面板内容
        CenterJP.repaint();    //刷新屏幕
        String FileName1=&quot;src/visitor/Picture/&quot;+Cuprum+&quot;.jpg&quot;;
        String FileName2=&quot;src/visitor/Picture/&quot;+paper+&quot;.jpg&quot;;
        JLabel lb=new JLabel(new ImageIcon(FileName1),JLabel.CENTER);
        JLabel rb=new JLabel(new ImageIcon(FileName2),JLabel.CENTER);
        CenterJP.add(lb);
        CenterJP.add(rb);
        this.setVisible(true);
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            
    &#125;
    @Override
    public void itemStateChanged(ItemEvent arg0)
    &#123;
        JRadioButton jc=(JRadioButton) arg0.getSource();
        if (jc.isSelected())
        &#123;
            if (jc.getText()==&quot;造币公司&quot;)
            &#123;
                select=(os.accept(visitor2)).split(&quot; &quot;);
            &#125;
            else
            &#123;            
                select=(os.accept(visitor1)).split(&quot; &quot;);
            &#125;
            showPicture(select[0],select[1]);    //显示选择的产品
        &#125;    
    &#125;
&#125;
//抽象访问者:公司
interface Company
&#123;
    String create(Paper element);
    String create(Cuprum element);
&#125;
//具体访问者：艺术公司
class ArtCompany implements Company
&#123;
    public String create(Paper element)
    &#123;
        return &quot;讲学图&quot;;
    &#125;
    public String create(Cuprum element)
    &#123;
        return &quot;朱熹铜像&quot;;
    &#125;
&#125;
//具体访问者：造币公司
class Mint implements Company
&#123;
    public String create(Paper element)
    &#123;
        return &quot;纸币&quot;;
    &#125;
    public String create(Cuprum element)
    &#123;
        return &quot;铜币&quot;;
    &#125;
&#125;
//抽象元素：材料
interface Material
&#123;
    String accept(Company visitor);
&#125;
//具体元素：纸
class Paper implements Material
&#123;
    public String accept(Company visitor)
    &#123;
        return(visitor.create(this));
    &#125;
&#125;
//具体元素：铜
class Cuprum implements Material
&#123;
    public String accept(Company visitor)
    &#123;
        return(visitor.create(this));
    &#125;
&#125;
//对象结构角色:材料集
class SetMaterial
&#123;   
    private List&lt;Material&gt; list=new ArrayList&lt;Material&gt;();   
    public String accept(Company visitor)
    &#123;
        Iterator&lt;Material&gt; i=list.iterator();
        String tmp=&quot;&quot;;
        while(i.hasNext())
        &#123;
            tmp+=((Material) i.next()).accept(visitor)+&quot; &quot;;
        &#125;
        return tmp; //返回某公司的作品集     
    &#125;
    public void add(Material element)
    &#123;
        list.add(element);
    &#125;
    public void remove(Material element)
    &#123;
        list.remove(element);
    &#125;
&#125;</code></pre>
<h4 id="模式的应用场景-8"><a href="#模式的应用场景-8" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h4><ol>
<li>对象结构相对稳定，但其操作算法经常变化的程序。</li>
<li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</li>
<li>对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。</li>
</ol>
<h4 id="模式的扩展-8"><a href="#模式的扩展-8" class="headerlink" title="模式的扩展"></a>模式的扩展</h4><p>访问者（Visitor）模式是使用频率较高的一种设计模式，它常常同以下两种设计模式联用。</p>
<p>(1)与“迭代器模式”联用。因为访问者模式中的“对象结构”是一个包含元素角色的容器，当访问者遍历容器中的所有元素时，常常要用迭代器。如【例1】中的对象结构是用 List 实现的，它通过 List 对象的 Itemtor() 方法获取迭代器。如果对象结构中的聚合类没有提供迭代器，也可以用迭代器模式自定义一个。</p>
<p>(2)访问者（Visitor）模式同“组合模式”联用。因为访问者（Visitor）模式中的“元素对象”可能是叶子对象或者是容器对象，如果元素对象包含容器对象，就必须用到组合模式。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%8C%85%E5%90%AB%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h3 id="10-备忘录（Memento）模式"><a href="#10-备忘录（Memento）模式" class="headerlink" title="10.备忘录（Memento）模式"></a>10.备忘录（Memento）模式</h3><p>每个人都有犯错误的时候，都希望有种“后悔药”能弥补自己的过失，让自己重新开始，但现实是残酷的。在计算机应用中，客户同样会常常犯错误，能否提供“后悔药”给他们呢？当然是可以的，而且是有必要的。这个功能由“备忘录模式”来实现。 </p>
<p>其实很多应用软件都提供了这项功能，如 Word、记事本、Photoshop、Eclipse 等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 IE 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。 </p>
<p>备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。 </p>
<h4 id="模式的定义与特点-10"><a href="#模式的定义与特点-10" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h4><p>备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。 </p>
<p>备忘录模式是一种对象行为型模式，其主要优点如下。</p>
<ul>
<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li>
<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>
<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>
</ul>
<p>其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。 </p>
<h4 id="模式的结构与实现-9"><a href="#模式的结构与实现-9" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><p>备忘录模式的核心是设计备忘录类以及用于管理备忘录的管理者类。</p>
<h5 id="1-模式的结构-19"><a href="#1-模式的结构-19" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li>
<li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-19"><a href="#2-模式的实现-19" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><pre><code class="java">package memento;
public class MementoPattern
&#123;
    public static void main(String[] args)
    &#123;
        Originator or=new Originator();
        Caretaker cr=new Caretaker();       
        or.setState(&quot;S0&quot;); 
        System.out.println(&quot;初始状态:&quot;+or.getState());           
        cr.setMemento(or.createMemento()); //保存状态      
        or.setState(&quot;S1&quot;); 
        System.out.println(&quot;新的状态:&quot;+or.getState());        
        or.restoreMemento(cr.getMemento()); //恢复状态
        System.out.println(&quot;恢复状态:&quot;+or.getState());
    &#125;
&#125;
//备忘录
class Memento
&#123; 
    private String state; 
    public Memento(String state)
    &#123; 
        this.state=state; 
    &#125;     
    public void setState(String state)
    &#123; 
        this.state=state; 
    &#125;
    public String getState()
    &#123; 
        return state; 
    &#125;
&#125;
//发起人
class Originator
&#123; 
    private String state;     
    public void setState(String state)
    &#123; 
        this.state=state; 
    &#125;
    public String getState()
    &#123; 
        return state; 
    &#125;
    public Memento createMemento()
    &#123; 
        return new Memento(state); 
    &#125; 
    public void restoreMemento(Memento m)
    &#123; 
        this.setState(m.getState()); 
    &#125; 
&#125;
//管理者
class Caretaker
&#123; 
    private Memento memento;       
    public void setMemento(Memento m)
    &#123; 
        memento=m; 
    &#125;
    public Memento getMemento()
    &#123; 
        return memento; 
    &#125;
&#125;

初始状态:S0
新的状态:S1
恢复状态:S0</code></pre>
<h4 id="模式的应用实例-9"><a href="#模式的应用实例-9" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h4><p><strong>利用备忘录模式设计相亲游戏</strong> </p>
<p>假如有西施、王昭君、貂蝉、杨玉环四大美女同你相亲，你可以选择其中一位作为你的爱人；当然，如果你对前面的选择不满意，还可以重新选择，但希望你不要太花心；这个游戏提供后悔功能，用“备忘录模式”设计比较合适。</p>
<p>首先，先设计一个美女（Girl）类，它是备忘录角色，提供了获取和存储美女信息的功能；然后，设计一个相亲者（You）类，它是发起人角色，它记录当 前时刻的内部状态信息（临时妻子的姓名），并提供创建备忘录和恢复备忘录数据的功能；最后，定义一个美女栈（GirlStack）类，它是管理者角色，负责对备忘录进行管理，用于保存相亲者（You）前面选过的美女信息，不过最多只能保存 4 个，提供后悔功能。</p>
<p>客户类设计成窗体程序，它包含美女栈（GirlStack）对象和相亲者（You）对象，它实现了 ActionListener 接口的事件处理方法 actionPerformed(ActionEvent e)，并将 4 大美女图像和相亲者（You）选择的美女图像在窗体中显示出来。 </p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E7%9B%B8%E4%BA%B2%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package memento;
import java.awt.GridLayout;
import java.awt.event.*;
import javax.swing.*;
public class DatingGame
&#123;
    public static void main(String[] args)
    &#123;
        new DatingGameWin();
    &#125;
&#125;
//客户窗体类
class DatingGameWin extends JFrame implements ActionListener
&#123;
    private static final long serialVersionUID=1L;   
    JPanel CenterJP,EastJP;
    JRadioButton girl1,girl2,girl3,girl4;
    JButton button1,button2;
    String FileName;
    JLabel g;
    You you;
    GirlStack girls;
    DatingGameWin()
    &#123;
        super(&quot;利用备忘录模式设计相亲游戏&quot;);
        you=new You();
        girls=new GirlStack();       
        this.setBounds(0,0,900,380);            
        this.setResizable(false);
        FileName=&quot;src/memento/Photo/四大美女.jpg&quot;;   
        g=new JLabel(new ImageIcon(FileName),JLabel.CENTER);
        CenterJP=new JPanel();
        CenterJP.setLayout(new GridLayout(1,4));
        CenterJP.setBorder(BorderFactory.createTitledBorder(&quot;四大美女如下：&quot;));
        CenterJP.add(g);   
        this.add(&quot;Center&quot;,CenterJP);
        EastJP=new JPanel();
        EastJP.setLayout(new GridLayout(1,1));
        EastJP.setBorder(BorderFactory.createTitledBorder(&quot;您选择的爱人是：&quot;));
        this.add(&quot;East&quot;,EastJP);
        JPanel SouthJP=new JPanel();      
        JLabel info=new JLabel(&quot;四大美女有“沉鱼落雁之容、闭月羞花之貌”，您选择谁？&quot;);
        girl1=new JRadioButton(&quot;西施&quot;,true);
        girl2=new JRadioButton(&quot;貂蝉&quot;);
        girl3=new JRadioButton(&quot;王昭君&quot;);       
        girl4=new JRadioButton(&quot;杨玉环&quot;);
        button1=new JButton(&quot;确定&quot;);
        button2=new JButton(&quot;返回&quot;);
        ButtonGroup group=new ButtonGroup();
        group.add(girl1);
        group.add(girl2);
        group.add(girl3);
        group.add(girl4);
        SouthJP.add(info);
        SouthJP.add(girl1);
        SouthJP.add(girl2);
        SouthJP.add(girl3);
        SouthJP.add(girl4);
        SouthJP.add(button1);
        SouthJP.add(button2);
        button1.addActionListener(this);
        button2.addActionListener(this);
        this.add(&quot;South&quot;,SouthJP);        
        showPicture(&quot;空白&quot;);
        you.setWife(&quot;空白&quot;);
        girls.push(you.createMemento());    //保存状态
    &#125;
    //显示图片
    void showPicture(String name)
    &#123;
        EastJP.removeAll(); //清除面板内容
        EastJP.repaint(); //刷新屏幕
        you.setWife(name);        
        FileName=&quot;src/memento/Photo/&quot;+name+&quot;.jpg&quot;;               
        g=new JLabel(new ImageIcon(FileName),JLabel.CENTER);                   
        EastJP.add(g);
        this.setVisible(true);
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            
    &#125;
    @Override
    public void actionPerformed(ActionEvent e)
    &#123;
        boolean ok=false;
        if(e.getSource()==button1)
        &#123;
            ok=girls.push(you.createMemento());    //保存状态  
            if(ok &amp;&amp; girl1.isSelected())
            &#123;
                showPicture(&quot;西施&quot;);
            &#125;
            else if(ok &amp;&amp; girl2.isSelected())
            &#123;
                showPicture(&quot;貂蝉&quot;);
            &#125;
            else if(ok &amp;&amp; girl3.isSelected())
            &#123;
                showPicture(&quot;王昭君&quot;);
            &#125;
            else if(ok &amp;&amp; girl4.isSelected())
            &#123;
                showPicture(&quot;杨玉环&quot;);
            &#125;               
        &#125;
        else if(e.getSource()==button2)
        &#123;
            you.restoreMemento(girls.pop()); //恢复状态
            showPicture(you.getWife());
        &#125;
    &#125;
&#125;
//备忘录：美女
class Girl
&#123; 
  private String name;
  public Girl(String name)
  &#123; 
      this.name=name; 
  &#125;     
  public void setName(String name)
  &#123; 
      this.name=name; 
  &#125;
  public String getName()
  &#123; 
      return name; 
  &#125;
&#125;
//发起人：您
class You
&#123; 
    private String wifeName;    //妻子
    public void setWife(String name)
    &#123; 
        wifeName=name; 
    &#125;
    public String getWife()
    &#123; 
        return wifeName; 
    &#125;
    public Girl createMemento()
    &#123; 
        return new Girl(wifeName); 
    &#125;
    public void restoreMemento(Girl p)
    &#123; 
        setWife(p.getName());
    &#125; 
&#125;
//管理者：美女栈
class GirlStack
&#123; 
    private Girl girl[];
    private int top;
    GirlStack()
    &#123;
        girl=new Girl[5];
        top=-1;
    &#125;
    public boolean push(Girl p)
    &#123;
        if(top&gt;=4)
        &#123;
            System.out.println(&quot;你太花心了，变来变去的！&quot;);
            return false;
        &#125;
        else
        &#123;
            girl[++top]=p;
            return true;
        &#125;
    &#125;
    public Girl pop()
    &#123;
        if(top&lt;=0)
        &#123;
            System.out.println(&quot;美女栈空了！&quot;);
            return girl[0];
        &#125;
        else return girl[top--]; 
    &#125;
&#125;</code></pre>
<h4 id="模式的应用场景-9"><a href="#模式的应用场景-9" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h4><ol>
<li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li>
<li>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li>
</ol>
<h4 id="模式的扩展-9"><a href="#模式的扩展-9" class="headerlink" title="模式的扩展"></a>模式的扩展</h4><p>在前面介绍的备忘录模式中，有单状态备份的例子，也有多状态备份的例子。下面介绍备忘录模式如何同原型模式混合使用。在备忘录模式中，通过定义“备忘录”来备份“发起人”的信息，而原型模式的 clone() 方法具有自备份功能，所以，如果让发起人实现 Cloneable 接口就有备份自己的功能，这时可以删除备忘录类。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E5%B8%A6%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package memento;
public class PrototypeMemento
&#123;
    public static void main(String[] args)
    &#123;
        OriginatorPrototype or=new OriginatorPrototype();
        PrototypeCaretaker cr=new PrototypeCaretaker();       
        or.setState(&quot;S0&quot;); 
        System.out.println(&quot;初始状态:&quot;+or.getState());           
        cr.setMemento(or.createMemento()); //保存状态      
        or.setState(&quot;S1&quot;); 
        System.out.println(&quot;新的状态:&quot;+or.getState());        
        or.restoreMemento(cr.getMemento()); //恢复状态
        System.out.println(&quot;恢复状态:&quot;+or.getState());
    &#125;
&#125;
//发起人原型
class OriginatorPrototype  implements Cloneable
&#123; 
    private String state;     
    public void setState(String state)
    &#123; 
        this.state=state; 
    &#125;
    public String getState()
    &#123; 
        return state; 
    &#125;
    public OriginatorPrototype createMemento()
    &#123; 
        return this.clone(); 
    &#125; 
    public void restoreMemento(OriginatorPrototype opt)
    &#123; 
        this.setState(opt.getState()); 
    &#125;
    public OriginatorPrototype clone()
    &#123;
        try
        &#123;
            return (OriginatorPrototype) super.clone();
        &#125;
        catch(CloneNotSupportedException e)
        &#123;
            e.printStackTrace();
        &#125;
        return null;
    &#125;
&#125;
//原型管理者
class PrototypeCaretaker
&#123; 
    private OriginatorPrototype opt;       
    public void setMemento(OriginatorPrototype opt)
    &#123; 
        this.opt=opt; 
    &#125;
    public OriginatorPrototype getMemento()
    &#123; 
        return opt; 
    &#125;
&#125;

初始状态:S0
新的状态:S1
恢复状态:S0</code></pre>
<h3 id="11-解释器（Interpreter）模式"><a href="#11-解释器（Interpreter）模式" class="headerlink" title="11.解释器（Interpreter）模式"></a>11.解释器（Interpreter）模式</h3><p>在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。</p>
<p>虽然使用解释器模式的实例不是很多，但对于满足以上特点，且对运行效率要求不是很高的应用实例，如果用解释器模式来实现，其效果是非常好的，本文将介绍其工作原理与使用方法。 </p>
<h4 id="模式的定义与特点-11"><a href="#模式的定义与特点-11" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h4><p>解释器（Interpreter）模式的定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。 </p>
<p>这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。例如，汉语中的句子有很多，“我是中国人”是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。 </p>
<p>解释器模式是一种类行为型模式，其主要优点如下。</p>
<ol>
<li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li>
<li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li>
</ol>
<p>解释器模式的主要缺点如下。</p>
<ol>
<li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li>
<li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li>
<li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</li>
</ol>
<h4 id="模式的结构与实现-10"><a href="#模式的结构与实现-10" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><p><strong>1) 文法</strong></p>
<p>文法是用于描述语言的语法结构的形式规则。没有规矩不成方圆，例如，有些人认为完美爱情的准则是“相互吸引、感情专一、任何一方都没有恋爱经历”，虽然最后一条准则较苛刻，但任何事情都要有规则，语言也一样，不管它是机器语言还是自然语言，都有它自己的文法规则。</p>
<pre><code>〈句子〉::=〈主语〉〈谓语〉〈宾语〉
〈主语〉::=〈代词〉|〈名词〉
〈谓语〉::=〈动词〉
〈宾语〉::=〈代词〉|〈名词〉
〈代词〉你|我|他
〈名词〉7大学生I筱霞I英语
〈动词〉::=是|学习</code></pre>
<blockquote>
<p>这里的符号“::=”表示“定义为”的意思，用“〈”和“〉”括住的是非终结符，没有括住的是终结符。 </p>
</blockquote>
<p><strong>2) 句子</strong></p>
<p>句子是语言的基本单位，是语言集中的一个元素，它由终结符构成，能由“文法”推导出。例如，上述文法可以推出“我是大学生”，所以它是句子。</p>
<p><strong>3) 语法树</strong></p>
<p>语法树是句子结构的一种树型表示，它代表了句子的推导结果，它有利于理解句子语法结构的层次。</p>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E2%80%9C%E6%88%91%E6%98%AF%E5%A4%A7%E5%AD%A6%E7%94%9F%E2%80%9D%E7%9A%84%E8%AF%AD%E6%B3%95%E6%A0%91.gif"></p>
<p>有了以上基础知识，现在来介绍解释器模式的结构就简单了。解释器模式的结构与组合模式相似，不过其包含的组成元素比组合模式多，而且组合模式是对象结构型模式，而解释器模式是类行为型模式。 </p>
<h5 id="1-模式的结构-20"><a href="#1-模式的结构-20" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h5><ol>
<li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li>
<li>终结符表达式（Terminal  Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li>
<li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li>
<li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li>
<li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li>
</ol>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<h5 id="2-模式的实现-20"><a href="#2-模式的实现-20" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h5><p><strong>解释器模式实现的关键是定义文法规则、设计终结符类与非终结符类、画出结构图，必要时构建语法树。</strong> </p>
<pre><code class="java">//抽象表达式类
interface AbstractExpression
&#123;
    public Object interpret(String info);    //解释方法
&#125;
//终结符表达式类
class TerminalExpression implements AbstractExpression
&#123;
    public Object interpret(String info)
    &#123;
        //对终结符表达式的处理
    &#125;
&#125;
//非终结符表达式类
class NonterminalExpression implements AbstractExpression
&#123;
    private AbstractExpression exp1;
    private AbstractExpression exp2;
    public Object interpret(String info)
    &#123;
        //非对终结符表达式的处理
    &#125;
&#125;
//环境类
class Context
&#123;
    private AbstractExpression exp;
    public Context()
    &#123;
        //数据初始化
    &#125;
    public void operation(String info)
    &#123;
        //调用相关表达式类的解释方法
    &#125;
&#125;</code></pre>
<h4 id="模式的应用实例-10"><a href="#模式的应用实例-10" class="headerlink" title="模式的应用实例"></a>模式的应用实例</h4><p><strong>用解释器模式设计一个“韶粵通”公交车卡的读卡器程序</strong> </p>
<p>假如“韶粵通”公交车读卡器可以判断乘客的身份，如果是“韶关”或者“广州”的“老人” “妇女”“儿童”就可以免费乘车，其他人员乘车一次扣 2 元。 </p>
<p>本实例用“解释器模式”设计比较适合，首先设计其文法规则如下。 </p>
<pre><code class="xml">&lt;expression&gt; ::= &lt;city&gt;的&lt;person&gt;
&lt;city&gt; ::= 韶关|广州
&lt;person&gt; ::= 老人|妇女|儿童</code></pre>
<p>然后，根据文法规则按以下步骤设计公交车卡的读卡器程序的类图。</p>
<ul>
<li>定义一个抽象表达式（Expression）接口，它包含了解释方法 interpret(String  info)。</li>
<li>定义一个终结符表达式（Terminal Expression）类，它用集合（Set）类来保存满足条件的城市或人，并实现抽象表达式接口中的解释方法 interpret(Stringinfo)，用来判断被分析的字符串是否是集合中的终结符。</li>
<li>定义一个非终结符表达式（AndExpressicm）类，它也是抽象表达式的子类，它包含满足条件的城市的终结符表达式对象和满足条件的人员的终结符表达式对象，并实现 interpret(String info) 方法，用来判断被分析的字符串是否是满足条件的城市中的满足条件的人员。</li>
<li>最后，定义一个环境（Context）类，它包含解释器需要的数据，完成对终结符表达式的初始化，并定义一个方法 freeRide(String info) 调用表达式对象的解释方法来对被分析的字符串进行解释。</li>
</ul>
<p><img src="https://gitee.com/bigpaozz/img_md/raw/master/%E2%80%9C%E9%9F%B6%E7%B2%B5%E9%80%9A%E2%80%9D%E5%85%AC%E4%BA%A4%E8%BD%A6%E8%AF%BB%E5%8D%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE.gif"></p>
<pre><code class="java">package interpreterPattern;
import java.util.*;
/*文法规则
  &lt;expression&gt; ::= &lt;city&gt;的&lt;person&gt;
  &lt;city&gt; ::= 韶关|广州
  &lt;person&gt; ::= 老人|妇女|儿童
*/
public class InterpreterPatternDemo
&#123;
    public static void main(String[] args)
    &#123;
        Context bus=new Context();
        bus.freeRide(&quot;韶关的老人&quot;);
        bus.freeRide(&quot;韶关的年轻人&quot;);
        bus.freeRide(&quot;广州的妇女&quot;);
        bus.freeRide(&quot;广州的儿童&quot;);
        bus.freeRide(&quot;山东的儿童&quot;);
    &#125;
&#125;
//抽象表达式类
interface Expression
&#123;
    public boolean interpret(String info);
&#125;
//终结符表达式类
class TerminalExpression implements Expression
&#123;
    private Set&lt;String&gt; set= new HashSet&lt;String&gt;();
    public TerminalExpression(String[] data)
    &#123;
        for(int i=0;i&lt;data.length;i++)set.add(data[i]);
    &#125;
    public boolean interpret(String info)
    &#123;
        if(set.contains(info))
        &#123;
            return true;
        &#125;
        return false;
    &#125;
&#125;
//非终结符表达式类
class AndExpression implements Expression
&#123;
    private Expression city=null;    
    private Expression person=null;
    public AndExpression(Expression city,Expression person)
    &#123;
        this.city=city;
        this.person=person;
    &#125;
    public boolean interpret(String info)
    &#123;
        String s[]=info.split(&quot;的&quot;);       
        return city.interpret(s[0])&amp;&amp;person.interpret(s[1]);
    &#125;
&#125;
//环境类
class Context
&#123;
    private String[] citys=&#123;&quot;韶关&quot;,&quot;广州&quot;&#125;;
    private String[] persons=&#123;&quot;老人&quot;,&quot;妇女&quot;,&quot;儿童&quot;&#125;;
    private Expression cityPerson;
    public Context()
    &#123;
        Expression city=new TerminalExpression(citys);
        Expression person=new TerminalExpression(persons);
        cityPerson=new AndExpression(city,person);
    &#125;
    public void freeRide(String info)
    &#123;
        boolean ok=cityPerson.interpret(info);
        if(ok) System.out.println(&quot;您是&quot;+info+&quot;，您本次乘车免费！&quot;);
        else System.out.println(info+&quot;，您不是免费人员，本次乘车扣费2元！&quot;);   
    &#125;
&#125;

您是韶关的老人，您本次乘车免费！
韶关的年轻人，您不是免费人员，本次乘车扣费2元！
您是广州的妇女，您本次乘车免费！
您是广州的儿童，您本次乘车免费！
山东的儿童，您不是免费人员，本次乘车扣费2元！</code></pre>
<h4 id="模式的应用场景-10"><a href="#模式的应用场景-10" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h4><ol>
<li>当语言的文法较为简单，且执行效率不是关键问题时。</li>
<li>当问题重复出现，且可以用一种简单的语言来进行表达时。</li>
<li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。</li>
</ol>
<blockquote>
<p>解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在Java中可以用 Expression4J 或 Jep 等来设计。 </p>
</blockquote>
<h4 id="模式的扩展-10"><a href="#模式的扩展-10" class="headerlink" title="模式的扩展"></a>模式的扩展</h4><p>在项目开发中，如果要对数据表达式进行分析与计算，无须再用解释器模式进行设计了，Java 提供了以下强大的数学公式解析器：Expression4J、MESP(Math Expression String Parser) 和 Jep 等，它们可以解释一些复杂的文法，功能强大，使用简单。</p>
<p>现在以 Jep 为例来介绍该工具包的使用方法。Jep 是 Java expression parser 的简称，即 Java 表达式分析器，它是一个用来转换和计算数学表达式的 Java 库。通过这个程序库，用户可以以字符串的形式输入一个任意的公式，然后快速地计算出其结果。而且 Jep 支持用户自定义变量、常量和函数，它包括许多常用的数学函数和常量。</p>
<p>使用前先下载 Jep 压缩包，解压后，将 jep-x.x.x.jar 文件移到选择的目录中，在 Eclipse 的“Java 构建路径”对话框的“库”选项卡中选择“添加外部 JAR(X)…”，将该 Jep 包添加项目中后即可使用其中的类库。</p>
<p>下面以计算存款利息为例来介绍。存款利息的计算公式是：本金x利率x时间=利息:</p>
<pre><code class="java">package interpreterPattern;
import com.singularsys.jep.*;
public class JepDemo
&#123;
    public static void main(String[] args) throws JepException
    &#123;
        Jep jep=new Jep();
        //定义要计算的数据表达式
        String 存款利息=&quot;本金*利率*时间&quot;;
        //给相关变量赋值
        jep.addVariable(&quot;本金&quot;,10000);
        jep.addVariable(&quot;利率&quot;,0.038);
        jep.addVariable(&quot;时间&quot;,2);
        jep.parse(存款利息);    //解析表达式
        Object accrual=jep.evaluate();    //计算
        System.out.println(&quot;存款利息：&quot;+accrual);
    &#125;
&#125;

存款利息：760.0</code></pre>

  </article>

  
    
  <div class="nexmoe-post-copyright">
    <strong>本文作者：</strong>iceberg<br>
    <strong>本文链接：</strong><a href="http://example.com/2020/09/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="http:&#x2F;&#x2F;example.com&#x2F;2020&#x2F;09&#x2F;25&#x2F;%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;example.com&#x2F;2020&#x2F;09&#x2F;25&#x2F;%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&#x2F;</a><br>
    
      <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
    
  </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a>
    
</div>

  <div class="nexmoe-post-footer">
    <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: '80b2453b6d5f37ad6225',
        clientSecret: '43e99fa852795c9a7b3eb924b2558c64b84bbdeb',
        id: window.location.pathname,
        repo: 'nexmoe.github.io',
        owner: 'nexmoe',
        admin: 'nexmoe'
    })
    gitalk.render('gitalk')
</script>
</section>
  </div>
</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script >hljs.initHighlightingOnLoad();</script>


    <script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>


<script src="/js/app.js?v=1601001529627"></script>
  





</body>

</html>
